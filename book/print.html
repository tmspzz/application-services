<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Cross-platform Rust Components</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="shared/a-s.css">
        <link rel="stylesheet" href="shared/mermaid.css">

        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Application Services Rust Components</a></li><li class="chapter-item expanded "><a href="contributing.html"><strong aria-hidden="true">1.</strong> Contributing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="building.html"><strong aria-hidden="true">1.1.</strong> Building</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="howtos/locally-published-components-in-fenix.html"><strong aria-hidden="true">1.1.1.</strong> How to use the local development autopublish flow for Fenix</a></li><li class="chapter-item expanded "><a href="howtos/locally-published-components-in-ios.html"><strong aria-hidden="true">1.1.2.</strong> How to use the local development flow for Firefox iOS</a></li><li class="chapter-item expanded "><a href="howtos/locally-published-spm-in-ios.html"><strong aria-hidden="true">1.1.3.</strong> How to use the local development flow for Focus for iOS</a></li><li class="chapter-item expanded "><a href="howtos/locally-building-jna.html"><strong aria-hidden="true">1.1.4.</strong> How to locally build JNA</a></li></ol></li><li class="chapter-item expanded "><a href="howtos/testing-a-rust-component.html"><strong aria-hidden="true">1.2.</strong> How to test Rust Components</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="howtos/smoke-testing-app-services.html"><strong aria-hidden="true">1.2.1.</strong> How to integration (smoke) test application-services</a></li><li class="chapter-item expanded "><a href="design/test-faster.html"><strong aria-hidden="true">1.2.2.</strong> Writing efficient tests</a></li></ol></li><li class="chapter-item expanded "><a href="dependency-management.html"><strong aria-hidden="true">1.3.</strong> Dependency management</a></li><li class="chapter-item expanded "><a href="howtos/adding-a-new-component.html"><strong aria-hidden="true">1.4.</strong> How to add a new component</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="howtos/building-a-rust-component.html"><strong aria-hidden="true">1.4.1.</strong> How to build a new syncable component</a></li><li class="chapter-item expanded "><a href="naming-conventions.html"><strong aria-hidden="true">1.4.2.</strong> Naming Conventions</a></li><li class="chapter-item expanded "><a href="howtos/converting-a-component-to-uniffi.html"><strong aria-hidden="true">1.4.3.</strong> How to convert a Rust Component to Uniffi</a></li><li class="chapter-item expanded "><a href="howtos/when-to-use-what-in-the-ffi.html"><strong aria-hidden="true">1.4.4.</strong> How to know what to use when in the FFI</a></li><li class="chapter-item expanded "><a href="android-faqs.html"><strong aria-hidden="true">1.4.5.</strong> How to use Rust Components in Android</a></li><li class="chapter-item expanded "><a href="howtos/consuming-rust-components-on-ios.html"><strong aria-hidden="true">1.4.6.</strong> How to use Rust Components on iOS</a></li></ol></li><li class="chapter-item expanded "><a href="logging.html"><strong aria-hidden="true">1.5.</strong> Logging</a></li></ol></li><li class="chapter-item expanded "><a href="adr/index.html"><strong aria-hidden="true">2.</strong> Architectural Decision Records</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="adr/0000-use-markdown-architectural-decision-records.html"><strong aria-hidden="true">2.1.</strong> ADR-0000</a></li><li class="chapter-item expanded "><a href="adr/0001-update-logins-api.html"><strong aria-hidden="true">2.2.</strong> ADR-0001</a></li><li class="chapter-item expanded "><a href="adr/0002-database-corruption.html"><strong aria-hidden="true">2.3.</strong> ADR-0002</a></li><li class="chapter-item expanded "><a href="adr/0003-swift-packaging.html"><strong aria-hidden="true">2.4.</strong> ADR-0003</a></li><li class="chapter-item expanded "><a href="adr/0004-early-startup-experiments.html"><strong aria-hidden="true">2.5.</strong> ADR-0004</a></li></ol></li><li class="chapter-item expanded "><a href="design/index.html"><strong aria-hidden="true">3.</strong> Design</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="design/megazords.html"><strong aria-hidden="true">3.1.</strong> Megazords</a></li><li class="chapter-item expanded "><a href="design/sync-manager.html"><strong aria-hidden="true">3.2.</strong> Sync Manager</a></li><li class="chapter-item expanded "><a href="design/sync-overview.html"><strong aria-hidden="true">3.3.</strong> Sync overview</a></li><li class="chapter-item expanded "><a href="design/swift-package-manager.html"><strong aria-hidden="true">3.4.</strong> Shipping Rust Components as Swift Packages</a></li><li class="chapter-item expanded "><a href="design/components-strategy.html"><strong aria-hidden="true">3.5.</strong> Rust Component's Strategy</a></li><li class="chapter-item expanded "><a href="design/metrics.html"><strong aria-hidden="true">3.6.</strong> Metrics - (Glean Telemetry)</a></li><li class="chapter-item expanded "><a href="design/rust-versions.html"><strong aria-hidden="true">3.7.</strong> Rust Version Policy</a></li></ol></li><li class="chapter-item expanded "><a href="howtos/cut-a-new-release.html"><strong aria-hidden="true">4.</strong> How to cut a new release</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="build-and-publish-pipeline.html"><strong aria-hidden="true">4.1.</strong> CI Publishing tools and flow</a></li><li class="chapter-item expanded "><a href="howtos/upgrading-nss-guide.html"><strong aria-hidden="true">4.2.</strong> How to upgrade NSS</a></li></ol></li><li class="chapter-item expanded "><a href="rust-docs/fxa_client/index.html"><strong aria-hidden="true">5.</strong> Rustdocs for components</a></li><li class="chapter-item expanded "><a href="adding-docs.html"><strong aria-hidden="true">6.</strong> Adding to these documents</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Cross-platform Rust Components</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/mozilla/application-services" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="application-services-rust-components"><a class="header" href="#application-services-rust-components">Application Services Rust Components</a></h1>
<p>Application Services is collection of Rust Components. The components are used to enable Firefox, and related applications to integrate with Firefox accounts, sync and enable experimentation. Each component is built using a core of shared code written in Rust, wrapped with native language bindings for different platforms.</p>
<h2 id="contact-us"><a class="header" href="#contact-us">Contact us</a></h2>
<p>To contact the Application Services team you can:</p>
<ul>
<li>Find us in the chat <a href="https://chat.mozilla.org/#/room/#rust-components:mozilla.org">#rust-components:mozilla.org</a> (<a href="https://wiki.mozilla.org/Matrix#Connect_to_Matrix">How to connect</a>)</li>
<li>To report issues with sync on <strong>Firefox Desktop</strong>, file a bug in <a href="https://bugzilla.mozilla.org/enter_bug.cgi?product=Firefox&amp;component=Sync">Bugzilla for Firefox :: Sync</a></li>
<li>To report issues with our components, file an issue in <a href="https://github.com/mozilla/application-services/issues">the GitHub issue tracker</a></li>
</ul>
<p>The source code is available <a href="https://github.com/mozilla/application-services/">on GitHub</a>.</p>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p>The Application Services Source Code is subject to the terms of the Mozilla Public License v2.0.
You can obtain a copy of the MPL at <a href="https://mozilla.org/MPL/2.0/">https://mozilla.org/MPL/2.0/</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributing-to-application-services"><a class="header" href="#contributing-to-application-services">Contributing to Application Services</a></h1>
<p>Anyone is welcome to help with the <a href="index.html">Application Services</a> project. Feel free to get in touch with <a href="./index.html#contact-us">other community members on Matrix or through issues on GitHub.</a></p>
<p>Participation in this project is governed by the
<a href="https://www.mozilla.org/en-US/about/governance/policies/participation/">Mozilla Community Participation Guidelines</a>.</p>
<h2 id="bug-reports"><a class="header" href="#bug-reports">Bug Reports</a></h2>
<p>You can file issues on <a href="https://github.com/mozilla/application-services/issues">GitHub</a>. Please try to include as much information as you can and under what conditions
you saw the issue.</p>
<h2 id="building-the-project"><a class="header" href="#building-the-project">Building the project</a></h2>
<p>Build instructions are available in the <a href="building.html"><code>building</code></a> page. Please let us know if you encounter any pain-points setting up your environment.</p>
<h2 id="finding-issues"><a class="header" href="#finding-issues">Finding issues</a></h2>
<p>Below are a few different queries you can use to find appropriate issues to work on. Feel free to reach out if you need any additional clarification before picking up an issue.</p>
<ul>
<li><strong><a href="https://github.com/mozilla/application-services/issues?q=is%3Aopen+is%3Aissue+label%3Agood-first-issue">good first issues</a></strong> -  If you are a new contributor, search for issues labeled <code>good-first-issue</code></li>
<li><strong><a href="https://github.com/mozilla/application-services/labels/good-second-issue">good second issues</a></strong> - Once you've got that first PR approved and you are looking for something a little more challenging, we are keeping a list of next-level issues. Search for the <code>good-second-issue</code> label.</li>
<li><strong><a href="https://github.com/mozilla/application-services/issues?utf8=%E2%9C%93&amp;q=is%3Aissue+is%3Aopen+%22Epic%3A+papercuts%22+">papercuts</a></strong> - A collection of smaller sized issues that may be a bit more advanced than a first or second issue.</li>
<li><strong><a href="https://github.com/mozilla/application-services/issues?utf8=%E2%9C%93&amp;q=is%3Aissue+is%3Aopen+%22Epic%3A+important+not+urgent%22">important, but not urgent</a></strong> - For more advanced contributors, we have a collection of issues that we consider important and would like to resolve sooner, but work isn't currently prioritized by the core team.</li>
</ul>
<h2 id="sending-pull-requests"><a class="header" href="#sending-pull-requests">Sending Pull Requests</a></h2>
<p>Patches should be submitted as <a href="https://help.github.com/articles/about-pull-requests/">pull requests</a> (PRs).</p>
<blockquote>
<p>When submitting PRs, We expect external contributors to push patches to a <a href="https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/working-with-forks">fork</a> of <a href="https://github.com/mozilla/application-services"><code>application-services</code></a>. For more information about submitting PRs from forks, read <a href="https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/creating-a-pull-request-from-a-fork">GitHub's guide</a>.</p>
</blockquote>
<p>Before submitting a PR:</p>
<ul>
<li>Your patch should include new tests that cover your changes, or be accompanied by explanation for why it doesn't need any. It is your and your reviewer's responsibility to ensure your patch includes adequate tests.
<ul>
<li>Consult the <a href="./howtos/testing-a-rust-component.html">testing guide</a> for some tips on writing effective tests.</li>
</ul>
</li>
<li>Your code should pass all the automated tests before you submit your PR for review.
<ul>
<li>Before pushing your changes, run <code>./automation/tests.py changes</code>. The script will calculate which components were changed and run test suites, linters and formatters against those components. Because the script runs a limited set of tests, the script should execute in a fairly reasonable amount of time.
<ul>
<li>If you have modified any Swift code, also run <code>swiftformat --swiftversion 5</code> on the modified code.</li>
</ul>
</li>
</ul>
</li>
<li>Your patch should include a changelog entry in <a href="https://github.com/mozilla/application-services/blob/main/CHANGES_UNRELEASED.md">CHANGES_UNRELEASED.md</a> or an explanation of why
it does not need one. Any breaking changes to Swift or Kotlin binding APIs should be noted explicitly.</li>
<li>If your patch adds new dependencies, they must follow our <a href="./dependency-management.html">dependency management guidelines</a>.
Please include a summary of the due diligence applied in selecting new dependencies.</li>
<li>After you open a PR, our Continuous Integration system will run a full test suite.  It's possible that this step will result in errors not caught with the script so make sure to check the results.</li>
<li>&quot;Work in progress&quot; pull requests are welcome, but should be clearly labeled as such and should not be merged until all tests pass and the code has been reviewed.
<ul>
<li>You can label pull requests as &quot;Work in progress&quot; by using the Github PR UI to indicate this PR is a draft (<a href="https://docs.github.com/en/github/collaborating-with-issues-and-pull-requests/about-pull-requests#draft-pull-requests">learn more about draft PRs</a>).</li>
</ul>
</li>
</ul>
<p>When submitting a PR:</p>
<ul>
<li>You agree to license your code under the project's open source license (<a href="https://github.com/mozilla/application-services/blob/main/LICENSE">MPL 2.0</a>).</li>
<li>Base your branch off the current <code>main</code> branch.</li>
<li>Add both your code and new tests if relevant.</li>
<li>Please do not include merge commits in pull requests; include only commits with the new relevant code.</li>
<li>We encourage you to <a href="https://help.github.com/articles/managing-commit-signature-verification">GPG sign your commits</a>.</li>
</ul>
<h2 id="code-review"><a class="header" href="#code-review">Code Review</a></h2>
<p>This project is production Mozilla code and subject to our <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Developer_guide/Committing_Rules_and_Responsibilities">engineering practices and quality standards</a>. Every patch must be peer reviewed by a member of the Application Services team.</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/application-services/edit/main/docs/contributing.md">Edit this file on GitHub.</a></footer><div style="break-before: page; page-break-before: always;"></div><h1 id="building-application-services"><a class="header" href="#building-application-services">Building Application Services</a></h1>
<p>When working on Application Services, it's important to set up your environment for building the Rust code and the Android or iOS code needed by the application.</p>
<h2 id="first-time-builds"><a class="header" href="#first-time-builds">First time builds</a></h2>
<p>Building for the first time is more complicated than a typical Rust project.
To build for an end-to-end experience that enables you to test changes in
client applications like <strong>Firefox for Android (Fenix)</strong> and <strong>Firefox iOS</strong>, there are a number of build
systems required for all the dependencies. The initial setup is likely to take
a number of hours to complete.</p>
<h2 id="building-the-rust-components"><a class="header" href="#building-the-rust-components">Building the Rust Components</a></h2>
<p><em>Complete this section before moving to the android/iOS build instructions.</em></p>
<ol>
<li>Make sure you cloned the repository:</li>
</ol>
<pre><code class="language-shell">  $ git clone https://github.com/mozilla/application-services # (or use the ssh link)
  $ cd application-services
  $ git submodule update --init --recursive
</code></pre>
<ol start="2">
<li>
<p>Install Rust: install <a href="https://www.rust-lang.org/tools/install">via rustup</a></p>
</li>
<li>
<p>Install your system dependencies:</p>
<h4 id="linux"><a class="header" href="#linux">Linux</a></h4>
<ol>
<li>Install the system dependencies required for building NSS
<ol>
<li>Install gyp: <code>apt install gyp</code> (required for NSS)</li>
<li>Install ninja-build: <code>apt install ninja-build</code></li>
<li>Install python3 (at least 3.6): <code>apt install python3</code></li>
<li>Install zlib: <code>apt install zlib1g-dev</code></li>
</ol>
</li>
<li>Install the system dependencies required for SQLcipher
<ol>
<li>Install tcl: <code>apt install tclsh</code> (required for SQLcipher)</li>
</ol>
</li>
</ol>
<h4 id="macos"><a class="header" href="#macos">MacOS</a></h4>
<ol>
<li>Install Xcode: check the <a href="../.circleci/config.yml">ci config</a> for the correct
version.</li>
<li>Install Xcode tools: <code>xcode-select --install</code></li>
<li>Install homebrew: <a href="https://brew.sh/">via homebrew</a> (it's what we use for ci)</li>
<li>Install the system dependencies required for building NSS
<ol>
<li>Install ninja: <code>brew install ninja</code></li>
<li>Install gyp (via https://github.com/mogemimi/pomdog/wiki/How-to-Install-GYP)</li>
</ol>
</li>
<li>Install swift-protobuf: <code>brew install swift-protobuf</code></li>
</ol>
<h4 id="windows"><a class="header" href="#windows">Windows</a></h4>
<p><em>Install windows build tools</em></p>
<blockquote>
<p>Why <a href="https://docs.microsoft.com/en-us/windows/wsl/about">Windows Subsystem for Linux (WSL)</a>?</p>
<p>It's currently tricky to get some of these builds working on Windows, primarily due to our use of SQLcipher. By using WSL it is possible to get builds working, but still have them published to your &quot;native&quot; local maven cache so it's available for use by a &quot;native&quot; Android Studio.</p>
</blockquote>
<ol>
<li>Install <a href="https://docs.microsoft.com/en-us/windows/wsl/about">WSL</a> (recommended over native tooling)</li>
<li>Install unzip: <code>sudo apt install unzip</code></li>
<li>Install python3: <code>sudo apt install python3</code> <em>Note: must be python 3.6 or later</em></li>
<li>Install system build tools: <code>sudo apt install build-essential</code></li>
<li>Install zlib: <code>sudo apt-get install zlib1g-dev</code></li>
<li>Install tcl: <code>sudo apt install tcl-dev</code></li>
</ol>
</li>
<li>
<p>Check dependencies and environment variables by running: <code>./libs/verify-desktop-environment.sh</code></p>
</li>
</ol>
<blockquote>
<p>Note that this script might instruct you to set some environment variables, set those by adding them to your
<code>.zshrc</code> or <code>.bashrc</code> so they are set by default on your terminal</p>
</blockquote>
<ol start="6">
<li>Run cargo test: <code>cargo test</code></li>
</ol>
<p>Once you have successfully run <code>./libs/verify-desktop-environment.sh</code> and <code>cargo test</code> you can move to the <a href="building.html#building-for-fenix"><strong>Building for Fenix</strong></a> and <a href="building.html#building-for-firefox-ios"><strong>Building for iOS</strong></a> sections below to setup your local environment for testing with our client applications.</p>
<hr />
<h2 id="building-for-fenix"><a class="header" href="#building-for-fenix">Building for Fenix</a></h2>
<p>The following instructions assume that you are building <code>application-services</code> for Fenix, and want to take advantage of the
<a href="howtos/locally-published-components-in-fenix.html">Fenix Auto-publication workflow for android-components and application-services</a>.</p>
<ol>
<li>Install Android SDK, JAVA, NDK and set required env vars
<ol>
<li>Clone the <a href="https://github.com/mozilla-mobile/fenix/">Fenix</a> repository (<strong>not</strong> inside the Application Service repository).</li>
<li>Clone the <a href="https://github.com/mozilla-mobile/android-components/">android-components</a> repository (<strong>not</strong> inside the Application Service repository).</li>
<li>Install <a href="https://www.oracle.com/java/technologies/downloads/#java11">Java <strong>11</strong></a> for your system</li>
<li>Set <code>JAVA_HOME</code> to point to the JDK 11 installation directory.</li>
<li>Download and install <a href="https://developer.android.com/studio/#downloads">Android Studio</a>.</li>
<li>Set <code>ANDROID_SDK_ROOT</code> and <code>ANDROID_HOME</code> to the Android Studio sdk location and add it to your rc file (either <code>.zshrc</code> or <code>.bashrc</code> depending on the shell you use for your terminal).</li>
<li>Configure the required versions of NDK
<code>Configure menu &gt; System Settings &gt; Android SDK &gt; SDK Tools &gt; NDK &gt; Show Package Details &gt; NDK (Side by side)</code>
<ul>
<li>21.4.7075529 (required by Fenix; note: a specific NDK version isn't configured, this maps to default <a href="https://developer.android.com/studio/projects/install-ndk#default-ndk-per-agp">NDK version</a> for the <a href="https://github.com/mozilla-mobile/fenix/blob/main/buildSrc/src/main/java/Dependencies.kt#L11">AGP version</a>)</li>
<li>21.3.6528147 (required by Application Services, <a href="https://github.com/mozilla/application-services/blob/main/build.gradle#L30">as configured</a>)</li>
</ul>
</li>
</ol>
</li>
<li>If you are on Windows using WSL - drop to the section below, <a href="building.html#windows-setup-for-android-via-wsl">Windows setup
for Android (WSL)</a> before proceeding.</li>
<li>Check dependencies, environment variables
<ol>
<li>Run <code>./libs/verify-android-environment.sh</code></li>
<li>Follow instructions and rerun until it is successful.</li>
</ol>
</li>
</ol>
<h3 id="windows-setup-for-android-via-wsl"><a class="header" href="#windows-setup-for-android-via-wsl">Windows setup for Android (via WSL)</a></h3>
<p>Note: For non-Ubuntu linux versions, it may be necessary to execute <code>$ANDROID_HOME/tools/bin/sdkmanager &quot;build-tools;26.0.2&quot; &quot;platform-tools&quot; &quot;platforms;android-26&quot; &quot;tools&quot;</code>. See also <a href="https://gist.github.com/fdmnio/fd42caec2e5a7e93e12943376373b7d0">this gist</a> for additional information.</p>
<h4 id="configure-maven"><a class="header" href="#configure-maven">Configure Maven</a></h4>
<p>Configure maven to use the native windows maven repository - then, when doing <code>./gradlew install</code> from WSL, it ends up in the Windows maven repo. This means we can do a number of things with Android Studio in &quot;native&quot; windows and have then work correctly with stuff we built in WSL.</p>
<ol>
<li>Install maven: <code>sudo apt install maven</code></li>
<li>Confirm existence of (or create) a <code>~/.m2</code> folder</li>
<li>In the <code>~/.m2</code> create a file called <code>settings.xml</code></li>
<li>Add the content below replacing <code>{username}</code> with your username:</li>
</ol>
<pre><code class="language-xml">    &lt;settings&gt;
      &lt;localRepository&gt;/mnt/c/Users/{username}/.m2/repository&lt;/localRepository&gt;
    &lt;/settings&gt;
</code></pre>
<hr />
<h2 id="building-for-firefox-ios"><a class="header" href="#building-for-firefox-ios">Building for Firefox iOS</a></h2>
<ol>
<li>Install Carthage: <code>brew install carthage</code></li>
<li>Install <a href="https://github.com/xcpretty/xcpretty#installation">xcpretty</a>: <code>gem install xcpretty</code></li>
<li>Run <code>./libs/verify-ios-environment.sh</code> to check your setup and environment
variables.</li>
<li>Make any corrections recommended by the script and re-run.</li>
<li>Follow the guide for <a href="howtos/locally-published-components-in-ios.html">using local a-s builds in iOS</a></li>
</ol>
<blockquote>
<p>Note: The built Xcode project is located at <code>megazords/ios/MozillaAppServices.xcodeproj</code>.</p>
</blockquote>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/application-services/edit/main/docs/building.md">Edit this file on GitHub.</a></footer><div style="break-before: page; page-break-before: always;"></div><h1 id="using-locally-published-components-in-fenix"><a class="header" href="#using-locally-published-components-in-fenix">Using locally published components in Fenix</a></h1>
<p>It's often important to test work-in-progress changes to Application Services components against a real-world
consumer project. The most reliable method of performing such testing is to publish your
components to a local Maven repository, and adjust the consuming project to install them
from there.</p>
<p>With support from the upstream project, it's possible to do this in a single step using
our auto-publishing workflow.</p>
<h2 id="using-the-auto-publishing-workflow"><a class="header" href="#using-the-auto-publishing-workflow">Using the auto-publishing workflow</a></h2>
<p>Some consumers (notably <a href="https://github.com/mozilla-mobile/fenix/">Fenix</a>) have support for
automatically publishing and including a local development version of application-services
in their build. The workflow is:</p>
<ol>
<li>
<p>Check out the consuming project.</p>
</li>
<li>
<p>Edit (or create) the file <code>local.properties</code> <em>in the consuming project</em> and tell it where to
find your local checkout of application-services, by adding a line like:</p>
<p><code>autoPublish.application-services.dir=relative/path/to/your/checkout/of/application-services</code></p>
<p>Note that the path should be relative from the root of the consumer's directory. For example, if <code>application-services</code>
and <code>fenix</code> are at the same level, the relative path would be <code>../application-services</code></p>
</li>
<li>
<p>Build the consuming project following its usual build procedure, e.g. via <code>./gradlew assembleDebug</code> or <code>./gradlew test</code>.</p>
</li>
</ol>
<p>If all goes well, this should automatically build your checkout of <code>application-services</code>, publish it
to a local maven repository, and configure the consuming project to install it from there instead of
from our published releases.</p>
<h2 id="using-a-manual-workflow"><a class="header" href="#using-a-manual-workflow">Using a manual workflow</a></h2>
<p>Note: This is a bit tedious, and you should first try the auto-publishing workflow described
above. But if the auto-publishing workflow fails then it's important to know how to do the publishing process manually. Since most consuming apps get their copy of <code>application-services</code> via a dependency
on <code>android-components</code>, this procedure involves three separate repos:</p>
<ol>
<li>
<p>Inside the <code>application-services</code> repository root:</p>
<ol>
<li>
<p>In <a href="https://github.com/mozilla/application-services/blob/main/.buildconfig-android.yml"><code>.buildconfig-android.yml</code></a>, change
<code>libraryVersion</code> to end in <code>-TESTING$N</code> <sup><a href="howtos/locally-published-components-in-fenix.html#note1">1</a></sup>,
where <code>$N</code> is some number that you haven't used for this before.</p>
<p>Example: <code>libraryVersion: 0.27.0-TESTING3</code></p>
</li>
<li>
<p>Check your <code>local.properties</code> file, and add <code>rust.targets=x86</code> if you're
testing on the emulator, <code>rust.targets=arm</code> if you're testing on 32-bit
arm (arm64 for 64-bit arm, etc). This will make the build that's done in
the next step much faster.</p>
</li>
<li>
<p>Run <code>./gradlew publishToMavenLocal</code>. This may take between 5 and 10 minutes.</p>
</li>
</ol>
</li>
<li>
<p>Inside the <code>android-components</code> repository root:</p>
<ol>
<li>
<p>In <a href="https://github.com/mozilla-mobile/android-components/blob/main/.buildconfig.yml"><code>.buildconfig.yml</code></a>, change
<code>componentsVersion</code> to end in <code>-TESTING$N</code> <sup><a href="howtos/locally-published-components-in-fenix.html#note1">1</a></sup>,
where <code>$N</code> is some number that you haven't used for this before.</p>
<p>Example: <code>componentsVersion: 0.51.0-TESTING3</code></p>
</li>
<li>
<p>Inside <a href="https://github.com/mozilla-mobile/android-components/blob/main/buildSrc/src/main/java/Dependencies.kt"><code>buildSrc/src/main/java/Dependencies.kt</code></a>,
change <code>mozilla_appservices</code> to reference the <code>libraryVersion</code> you
published in step 1 part 1.</p>
<p>Example: <code>const val mozilla_appservices = &quot;0.27.0-TESTING3&quot;</code></p>
</li>
<li>
<p>Inside <a href="https://github.com/mozilla-mobile/android-components/blob/main/build.gradle"><code>build.gradle</code></a>, add
<code>mavenLocal()</code> inside <code>allprojects { repositories { &lt;here&gt; } }</code>.</p>
</li>
<li>
<p>Inside the android-components <code>local.properties</code> file, ensure
<code>autoPublish.application-services.dir</code> is <em>NOT</em> set.</p>
</li>
<li>
<p>Run <code>./gradlew publishToMavenLocal</code>.</p>
</li>
</ol>
</li>
<li>
<p>Inside the consuming project repository root:</p>
<ol>
<li>
<p>Inside <a href="https://github.com/mozilla-mobile/fenix/blob/main/build.gradle"><code>build.gradle</code></a>, add
<code>mavenLocal()</code> inside <code>allprojects { repositories { &lt;here&gt; } }</code>.</p>
</li>
<li>
<p>Ensure that <code>local.properties</code> does not contain any configuration to
related to auto-publishing the application-services repo.</p>
</li>
<li>
<p>Inside <a href="https://github.com/mozilla-mobile/fenix/blob/main/buildSrc/src/main/java/AndroidComponents.kt"><code>buildSrc/src/main/java/AndroidComponents.kt</code></a>, change the
version numbers for android-components to
match the new versions you defined above.</p>
<p>Example: <code>const val VERSION = &quot;0.51.0-TESTING3&quot;</code></p>
</li>
</ol>
</li>
</ol>
<p>You should now be able to build and run the consuming application (assuming you could
do so before all this).</p>
<h3 id="caveats"><a class="header" href="#caveats">Caveats</a></h3>
<ol>
<li>This assumes you have followed the <a href="howtos/../building.html#building-for-fenix">build instructions for Fenix</a></li>
<li>Make sure you're fully up to date in all repos, unless you know you need to
not be.</li>
<li>This omits the steps if changes needed because, e.g. <code>application-services</code>
made a breaking change to an API used in <code>android-components</code>. These should be
understandable to fix, you usually should be able to find a PR with the fixes
somewhere in the android-component's list of pending PRs (or, failing that, a
description of what to do in the application-services changelog).</li>
<li><a href="howtos/../README.html#contact-us">Contact us</a> if you get stuck.</li>
</ol>
<h2 id="adding-support-for-the-auto-publish-workflow"><a class="header" href="#adding-support-for-the-auto-publish-workflow">Adding support for the auto-publish workflow</a></h2>
<p>If you had to use the manual workflow above and found it incredibly tedious, you might like to
try adding support for the auto-publish workflow to the consuming project! The details will differ
depending on the specifics of the project's build setup, but at a high level you will need to:</p>
<ol>
<li>
<p>In your <a href="https://github.com/mozilla-mobile/fenix/blob/main/settings.gradle">settings.gradle</a>, locate (or add) the code for parsing the <code>local.properties</code> file,
and add support for loading a directory path from the property <code>autoPublish.application-services.dir</code>.</p>
<p>If this property is present, spawn a subprocess to run <code>./gradlew autoPublishForLocalDevelopment</code>
in the specified directory. This automates step (1) of the manual workflow above, publishing your
changes to <code>application-services</code> into a local maven repository under a unique version number.</p>
</li>
<li>
<p>In your <a href="https://github.com/mozilla-mobile/fenix/blob/main/build.gradle">build.gradle</a>, if the <code>autoPublish.application-services.dir</code> property
is present, have each project apply the build script from <code>./build-scripts/substitute-local-appservices.gradle</code>
in the specified directory.</p>
<p>This automates steps (2) and (3) of the manual workflow above, using gradle's dependency substitution
capabilities to override the verion requirements for application-services components. It may be necessary
to experiment with the ordering of this relative to other build configuration steps, in order for the
dependency substitution to work correctly.</p>
<p>For a single-project build this would look something like:</p>
<pre><code class="language-groovy">if (gradle.hasProperty('localProperties.autoPublish.application-services.dir')) {
   ext.appServicesSrcDir = gradle.&quot;localProperties.autoPublish.application-services.dir&quot;
   apply from: &quot;${appServicesSrcDir}/build-scripts/substitute-local-appservices.gradle&quot;
}
</code></pre>
<p>For a multi-project build it should be applied to all subprojects, like:</p>
<pre><code class="language-groovy">subprojects {
   if (gradle.hasProperty('localProperties.autoPublish.application-services.dir')) {
      ext.appServicesSrcDir = gradle.&quot;localProperties.autoPublish.application-services.dir&quot;
      apply from: &quot;${rootProject.projectDir}/${appServicesSrcDir}/build-scripts/substitute-local-appservices.gradle&quot;
   }
}
</code></pre>
</li>
<li>
<p>Confirm that the setup is working, by adding <code>autoPublish.application-services.dir</code> to your
<code>local.properties</code> file and running <code>./gradlew dependencies</code> for the project.</p>
<p>You should be able to see gradle checking the build status of the various application-services
dependencies as part of its setup phase. When the command completes, it should print the resolved
versions of all dependencies, and you should see that application-services components have a version
number in the format <code>0.0.1-SNAPSHOT-{TIMESTAMP}</code>.</p>
</li>
</ol>
<hr />
<p><b id="note1">[1]</b>: It doesn't have to start with <code>-TESTING</code>, it only needs
to have the format <code>-someidentifier</code>. <code>-SNAPSHOT$N</code> is also very common to use,
however without the numeric suffix, this has specific meaning to gradle, so we
avoid it.  Additionally, while the <code>$N</code> we have used in our running example has
matched (e.g. all of the identifiers ended in <code>-TESTING3</code>, this is not required,
so long as you match everything up correctly at the end. This can be tricky, so
I always try to use the same number).</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/application-services/edit/main/docs/howtos/locally-published-components-in-fenix.md">Edit this file on GitHub.</a></footer><div style="break-before: page; page-break-before: always;"></div><h1 id="using-locally-published-components-in-firefox-for-ios"><a class="header" href="#using-locally-published-components-in-firefox-for-ios">Using locally-published components in Firefox for iOS</a></h1>
<p>It's often important to test work-in-progress changes to this repo against a real-world
consumer project. Here are our current best-practices for approaching this on iOS:</p>
<ol>
<li>
<p>Make a local build of the application-services framework using <code>./build-carthage.sh</code>.</p>
</li>
<li>
<p>Checkout and <code>carthage bootstrap</code> the consuming app (for example using <a href="https://github.com/mozilla-mobile/firefox-ios#building-the-code">these instructions with Firefox for
iOS</a>).</p>
</li>
<li>
<p>In the consuming app, replace the application-services framework with a copy of your local build. For example:</p>
<pre><code>rm -rf Carthage/Build/iOS/MozillaAppServices.framework
rsync -ad path/to/application-services/Carthage/Build/iOS/MozillaAppServices.framework/ Carthage/Build/iOS/MozillaAppServices.framework/
</code></pre>
</li>
<li>
<p>Open the consuming app project in XCode and build it from there.</p>
</li>
</ol>
<p>After making changes to application-services code, you will need to re-run these steps in order to
copy the latest changes over into the consuming app.</p>
<p>Firefox for iOS also has a helper script that automates these steps:
<a href="https://github.com/mozilla-mobile/firefox-ios/blob/main/appservices_local_dev.sh"><code>appservices_local_dev.sh</code></a>.</p>
<p>Note that for firefox-ios specifically, you may also need to copy the Glean <code>sdk_generator.sh</code> script
from the appservices build into the root of the firefox-ios repository.</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/application-services/edit/main/docs/howtos/locally-published-components-in-ios.md">Edit this file on GitHub.</a></footer><div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-locally-test-swift-package-manager-components-on-focus-ios"><a class="header" href="#how-to-locally-test-swift-package-manager-components-on-focus-ios">How to locally test Swift Package Manager components on Focus iOS</a></h1>
<blockquote>
<p>This is a guide on testing the Swift Package Manager component locally against a local build of Focus iOS. For more information on our Swift Package Manager design, read the <a href="howtos/../adr/0003-swift-packaging.html">ADR that introduced it</a></p>
</blockquote>
<blockquote>
<p>This guide assumes the component you want to test is already distributed with the <a href="https://github.com/mozilla/rust-components-swift"><code>rust-components-swift</code></a> repository, you can read <a href="howtos/./adding-a-new-component.html#including-the-component-in-the-swift-package-manager-megazord">the guide for adding a new component</a> if you would like to distribute a new component.</p>
</blockquote>
<p>To test a component locally, you will need to do the following:</p>
<ol>
<li>Build an xcframework in a local checkout of <code>application-services</code></li>
<li>Include the xcframework in a local checkout of <code>rust-components-swift</code></li>
<li>Run the <code>make-tag</code> script in <code>rust-components-swift</code> using a local checkout of <code>application-services</code></li>
<li>Include the local checkout of <code>rust-components-swift</code> in <code>Focus</code></li>
</ol>
<p>Below are more detailed instructions for each step</p>
<h2 id="building-the-xcframework"><a class="header" href="#building-the-xcframework">Building the xcframework</a></h2>
<p>To build the <a href="https://developer.apple.com/documentation/swift_packages/distributing_binary_frameworks_as_swift_packages">xcframework</a> do the following:</p>
<ol>
<li>In a local checkout of <code>application-services</code>, navigate to <a href="https://github.com/mozilla/application-services/tree/main/megazords/ios-rust"><code>megazords/ios-rust/</code></a></li>
<li>Run the <code>build-xcframework.sh</code> script: 
<code>sh ./build-xcframework.sh </code>
This will produce a file name <code>MozillaRustComponents.xcframework.zip</code> that contains the following, built for all our target iOS platforms.
<ul>
<li>The compiled Rust code for all the crates listed in <code>Cargo.toml</code> as a static library</li>
<li>The C header files and <a href="https://clang.llvm.org/docs/Modules.html">Swift module maps</a> for the components</li>
</ul>
</li>
</ol>
<h2 id="include-the-xcframework-in-a-local-checkout-of-rust-components-swift"><a class="header" href="#include-the-xcframework-in-a-local-checkout-of-rust-components-swift">Include the xcframework in a local checkout of <code>rust-components-swift</code></a></h2>
<p>After you generated the <code>MozillaRustComponents.xcframework.zip</code> in the previous step, do the following to include it in a local checkout of <code>rust-components-swift</code>:</p>
<ol>
<li>clone a local checkout of <code>rust-components-swift</code>, <strong>not</strong> inside the <code>application-services</code> repository:
<pre><code class="language-sh">git clone https://github.com/mozilla/rust-components.swift.git
</code></pre>
</li>
<li>Unzip the <code>MozillaRustComponents.xcframework.zip</code> into the <code>rust-components-swift</code> repository: (Assuming you are in the root of the <code>rust-components-swift</code> directory and <code>application-services</code> is a neighbor directory)
<pre><code class="language-sh"> unzip  ../application-services/megazords/ios-rust/MozillaRustComponents.xcframework.zip -d .
</code></pre>
</li>
<li>Change the <code>Package.swift</code>'s reference to the xcframework to point to unzipped folder. You can do this by uncommenting the following line:
<pre><code class="language-swift">    path: &quot;./MozillaRustComponents.xcframework&quot;
</code></pre>
and commenting out the following lines:
<pre><code class="language-swift">    url: &quot;SOME_URL_THAT_POINTS_TO_RELEASE&quot;,
    checksum: &quot;SOME_CHECKSUM_FOR_RELEASE&quot;
</code></pre>
</li>
</ol>
<h2 id="run-the-make-tag-script-with-a-local-checkout-of-application-services"><a class="header" href="#run-the-make-tag-script-with-a-local-checkout-of-application-services">Run the make-tag script with a local checkout of application services</a></h2>
<p>For this step, run the following script from inside the <code>rust-components-swift</code> repository (assuming that <code>application-services</code> is a neighboring directory to <code>rust-components-swift</code>). Change the <code>X.Y.Z</code> to be a valid semver version, for example: <code>0.0.101</code></p>
<pre><code class="language-sh">./make_tag -l ../application-services X.Y.Z
</code></pre>
<p>Once that is done, your local checkout will now have a git tag <code>X.Y.Z</code> that can be pointed to by xCode</p>
<h2 id="include-the-local-checkout-of-rust-components-swift-in-focus"><a class="header" href="#include-the-local-checkout-of-rust-components-swift-in-focus">Include the local checkout of <code>rust-components-swift</code> in <code>Focus</code></a></h2>
<p>This is the final step to include your local changes into <code>Focus</code>. Do the following steps:</p>
<ol>
<li>Clone a local checkout of <code>Focus</code> if you haven't already. Make sure you also install the project dependencies, more information in their <a href="https://github.com/mozilla-mobile/focus-ios#build-instructions">build instructions</a></li>
<li>Open <code>Blockzilla.xcodeproj</code> in Xcode</li>
<li>Navigate to the Swift Packages in Xcode:
<img src="howtos/./img/xcode-blockzilla.png" alt="Screenshot of where to find the setting for Blockzilla" />
<img src="howtos/./img/xcode-package-deps.png" alt="Screenshot of where to find the package dependencies" /></li>
<li>Remove the dependency on <code>rust-components-swift</code> as listed on Xcode, you can click the dependency then click the <code>-</code></li>
<li>Add a new swift package by clicking the <code>+</code>:
<ol>
<li>On the top right, enter the full path to your <code>rust-components-swift</code> checkout, preceded by <code>file://</code>. If you don't know what that is, run <code>pwd</code> in while in <code>rust-components-swift</code>. For example: <code>file:///Users/tarikeshaq/code/rust-components-swift</code></li>
<li>Change the version to be an exact version and equal the <code>X.Y.Z</code> version you set in the previous step. For example, if I ran <code>./make_tag -l ../application-services 0.0.101</code>, then my version would be <code>0.0.101</code>. This is what the dialog should look like:
<img src="howtos/./img/xcode-package-include.png" alt="Dialog for including the rust-components-swift package" /></li>
<li>Click <code>Add Package</code></li>
<li>Now include the packages you would like to include, at the time of the writing of this doc, the packages to include in <code>Focus</code> are <code>Nimbus</code>, <code>Viaduct</code> and <code>RustLog</code>.</li>
</ol>
</li>
<li>Finally, attempt to build focus, and if all goes well it should launch  with your code. If you face any problems, feel free to <a href="howtos/../index.html#contact-us">contact us</a></li>
</ol>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/application-services/edit/main/docs/howtos/locally-published-spm-in-ios.md">Edit this file on GitHub.</a></footer><div style="break-before: page; page-break-before: always;"></div><h1 id="building-and-using-a-locally-modified-version-of-jna"><a class="header" href="#building-and-using-a-locally-modified-version-of-jna">Building and using a locally-modified version of JNA</a></h1>
<p><a href="https://github.com/java-native-access/jna/">Java Native Access</a> is an important dependency
for the Application Services components on Android, as it provides the low-level interface
from the JVM into the natively-compiled Rust code.</p>
<p>If you need to work with a locally-modified version of JNA (e.g. to investigate an apparent
JNA bug) then you may find these notes helpful.</p>
<hr />
<p>The JNA docs do have an <a href="https://github.com/java-native-access/jna/blob/master/www/AndroidDevelopmentEnvironment.md">Android Development Environment guide</a>
that is a good starting point, but the instructions did not work for me and appear a little out of date.
Here are the steps that worked for me:</p>
<ul>
<li>
<p>Modify your environment to specify <code>$NDK_PLATFORM</code>, and to ensure the Android NDK tools
for each target platform are in your <code>$PATH</code>. On my Mac with Android Studio the
config was as follows:</p>
<pre><code>export NDK_ROOT=&quot;$HOME/Library/Android/sdk/ndk/21.3.6528147&quot;
export NDK_PLATFORM=&quot;$NDK_ROOT/platforms/android-21&quot;
export PATH=&quot;$PATH:$NDK_ROOT/toolchains/llvm/prebuilt/darwin-x86_64/bin&quot;
export PATH=&quot;$PATH:$NDK_ROOT/toolchains/aarch64-linux-android-4.9/prebuilt/darwin-x86_64/bin&quot;
export PATH=&quot;$PATH:$NDK_ROOT/toolchains/arm-linux-androideabi-4.9/prebuilt/darwin-x86_64/bin&quot;
export PATH=&quot;$PATH:$NDK_ROOT/toolchains/x86-4.9/prebuilt/darwin-x86_64/bin&quot;
export PATH=&quot;$PATH:$NDK_ROOT/toolchains/x86_64-4.9/prebuilt/darwin-x86_64/bin&quot;
</code></pre>
<p>You will probably need to tweak the paths and version numbers based on your operating system and
the details of how you installed the Android NDK.</p>
</li>
<li>
<p>Install the <code>ant</code> build tool (using <code>brew install ant</code> worked for me).</p>
</li>
<li>
<p>Checkout the <a href="https://github.com/java-native-access/jna">JNA source</a> from Github. Try doing a basic
build via <code>ant dist</code> and <code>ant test</code>. This won't build for Android but will test the rest of the tooling.</p>
</li>
<li>
<p>Adjust <code>./native/Makefile</code> for compatibility with your Android NSK install. Here's what I had to do for mine:</p>
<ul>
<li>Adjust the <code>$CC</code> variable to use clang instead of gcc: <code>CC=aarch64-linux-android21-clang</code>.</li>
<li>Adjust thd <code>$CCP</code> variable to use the version from your system: <code>CPP=cpp</code>.</li>
<li>Add <code>-landroid -llog</code> to the list of libraries to link against in <code>$LIBS</code>.</li>
</ul>
</li>
<li>
<p>Build the JNA native libraries for the target platforms of interest:</p>
<ul>
<li><code>ant -Dos.prefix=android-aarch64</code></li>
<li><code>ant -Dos.prefix=android-armv7</code></li>
<li><code>ant -Dos.prefix=android-x86</code></li>
<li><code>ant -Dos.prefix=android-x86-64</code></li>
</ul>
</li>
<li>
<p>Package the newly-built native libraries into a JAR/AAR using <code>ant dist</code>.
This should produce <code>./dist/jna.aar</code>.</p>
</li>
<li>
<p>Configure <code>build.gradle</code> for the consuming application to use the locally-built JNA artifact:</p>
<pre><code>// Tell gradle where to look for local artifacts.
repositories {
    flatDir {
        dirs &quot;/PATH/TO/YOUR/CHECKOUT/OF/jna/dist&quot;
    }
}

// Tell gradle to exclude the published version of JNA.
configurations {
    implementation {
        exclude group: &quot;net.java.dev.jna&quot;, module:&quot;jna&quot;
    }
}

// Take a direct dependency on the local JNA AAR.
dependencies {
    implementation name: &quot;jna&quot;, ext: &quot;aar&quot;
}
</code></pre>
</li>
<li>
<p>Rebuild and run your consuming application, and it should be using the locally-built JNA!</p>
</li>
</ul>
<p>If you're trying to debug some unexpected JNA behaviour (and if you favour old-school printf-style debugging)
then you can this code snippet to print to the Android log from the compiled native code:</p>
<pre><code>#ifdef __ANDROID__
#include &lt;android/log.h&gt;
#define HACKY_ANDROID_LOG(...) __android_log_print(ANDROID_LOG_VERBOSE, &quot;HACKY-DEBUGGING-FOR-ALL&quot;, __VA_ARGS__)
#else
#define HACKY_ANDROID_LOG(MSG)
#endif

HACKY_ANDROID_LOG(&quot;this will go to the android logcat output&quot;);
HACKY_ANDROID_LOG(&quot;it accepts printf-style format sequences, like this: %d&quot;, 42);
</code></pre>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/application-services/edit/main/docs/howtos/locally-building-jna.md">Edit this file on GitHub.</a></footer><div style="break-before: page; page-break-before: always;"></div><h1 id="guide-to-testing-a-rust-component"><a class="header" href="#guide-to-testing-a-rust-component">Guide to Testing a Rust Component</a></h1>
<p>This document gives a high-level overview of how we test components in <code>application-services</code>.
It will be useful to you if you're adding a new component, or working on increasing the test
coverage of an existing component.</p>
<p>If you are only interested in running the existing test suite, please consult the
<a href="howtos/../contributing.html">contributor docs</a> and the <a href="https://github.com/mozilla/application-services/blob/main/automation/tests.py">tests.py</a> script.</p>
<h2 id="unit-and-functional-tests"><a class="header" href="#unit-and-functional-tests">Unit and Functional Tests</a></h2>
<h3 id="rust-code"><a class="header" href="#rust-code">Rust code</a></h3>
<p>Since the core implementations of our components live in rust, so does the core of our testing strategy.</p>
<p>Each rust component should be accompanied by a suite of unit tests, following the <a href="https://doc.rust-lang.org/book/ch11-00-testing.html">guidelines for writing
tests</a> from the <a href="https://doc.rust-lang.org/book/title-page.html">Rust
Book</a>.
Some additional tips:</p>
<ul>
<li>
<p>Where possible, it's better use use the Rust typesystem to make bugs impossible than to write
tests to assert that they don't occur in practice. But given that the ultimate consumers of our
code are not in Rust, that's sometimes not possible. The best idiomatic Rust API for a feature
is not necessarily the best API for consuming it over an FFI boundary.</p>
</li>
<li>
<p>Rust's builtin assertion macros are sparse; we use the <a href="https://crates.io/crates/more_asserts">more_asserts</a>
for some additional helpers.</p>
</li>
<li>
<p>Rust's strict typing can make test mocks difficult. If there's something you need to mock out in tests,
make it a Trait and use the <a href="https://crates.io/crates/mockiato">mockiato</a> crate to mock it.</p>
</li>
</ul>
<p>The Rust tests for a component should be runnable via <code>cargo test</code>.</p>
<h3 id="ffi-layer-code"><a class="header" href="#ffi-layer-code">FFI Layer code</a></h3>
<p>We are currently using <a href="howtos/converting-a-component-to-uniffi.html"><code>uniffi</code></a> to generate most ((and soon all!) of our FFI code and thus the FFI code itself does not need to be extensively tested.</p>
<h3 id="kotlin-code"><a class="header" href="#kotlin-code">Kotlin code</a></h3>
<p>The Kotlin wrapper code for a component should have its own test suite, which should follow the general guidelines for
<a href="https://github.com/mozilla-mobile/shared-docs/blob/main/android/testing.md#jvm-testing">testing Android code in Mozilla projects</a>.
In practice that means we use
<a href="https://github.com/mozilla-mobile/shared-docs/blob/main/android/testing.md#junit-testing-framework">JUnit</a>
as the test framework and
<a href="https://github.com/mozilla-mobile/shared-docs/blob/main/android/testing.md#robolectric-android-api-shadows">Robolectric</a>
to provide implementations of Android-specific APIs.</p>
<p>The Kotlin tests for a component should be runnable via <code>./gradlew &lt;component&gt;:test</code>.</p>
<p>The tests at this layer are designed to ensure that the API binding code is working as intended,
and should not repeat tests for functionality that is already well tested at the Rust level.
But given that the Kotlin bindings involve a non-trivial amount of hand-written boilerplate code,
it's important to exercise that code throughly.</p>
<p>One complication with running Kotlin tests is that the code needs to run on your local development machine,
but the Kotlin code's native dependencies are typically compiled and packaged for Android devices. The
tests need to ensure that an appropriate version of JNA and of the compiled Rust code is available in
their library search path at runtime. Our <code>build.gradle</code> files contain a collection of hackery that ensures
this, which should be copied into any new components.</p>
<p>The majority of our Kotlin bindings are autogenerated using <a href="howtos/converting-a-component-to-uniffi.html"><code>uniffi</code></a> and do not need extensive testing.</p>
<h3 id="swift-code"><a class="header" href="#swift-code">Swift code</a></h3>
<p>The Swift wrapper code for a component should have its own test suite, using Apple's
<a href="https://developer.apple.com/documentation/xctest">XCode unittest framework</a>.</p>
<p>Due to the way that all rust components need to be compiled together into a single <a href="howtos/../design/megazords.html">&quot;megazord&quot;</a>
framework, this entire respository is a single XCode project. The Swift tests for each component
thus need to live under <code>megazords/ios/MozillaAppServicesTests/</code> rather than in the directory
for the corresponding component. (XXX TODO: is this true? it would be nice to find a way to avoid havining
them live separately because it makes them easy to overlook).</p>
<p>The tests at this layer are designed to ensure that the API binding code is working as intended,
and should not repeat tests for functionality that is already well tested at the Rust level.
But given that the Swift bindings involve a non-trivial amount of hand-written boilerplate code,
it's important to exercise that code throughly.</p>
<p>The majority of our Swift bindings are autogenerated using <a href="howtos/converting-a-component-to-uniffi.html"><code>uniffi</code></a> and do not need extensive testing.</p>
<h2 id="integration-tests"><a class="header" href="#integration-tests">Integration tests</a></h2>
<h3 id="end-to-end-sync-tests"><a class="header" href="#end-to-end-sync-tests">End-to-end Sync Tests</a></h3>
<p>The <a href="https://github.com/mozilla/application-services/tree/main/testing/sync-test"><code>testing/sync-test</code></a> directory contains a test harness for running sync-related
Rust components against a live Firefox Sync infrastructure, so that we can verifying the functionality
end-to-end.</p>
<p>Each component that implements a sync engine should have a corresponding suite of tests in this directory.</p>
<ul>
<li>XXX TODO: places doesn't.</li>
<li>XXX TODO: send-tab doesn't (not technically a sync engine, but still, it's related)</li>
<li>XXX TODO: sync-manager doesn't</li>
</ul>
<h3 id="android-components-test-suite"><a class="header" href="#android-components-test-suite">Android Components Test Suite</a></h3>
<p>It's important that changes in <code>application-services</code> are tested against upstream consumer code in the
<a href="https://github.com/mozilla-mobile/android-components/">android-components</a> repo. This is currently
a manual process involving:</p>
<ul>
<li>Configuring your local checkout of android-components to <a href="howtos/./locally-published-components-in-fenix.html">use your local application-services
build</a>.</li>
<li>Running the android-components test suite via <code>./gradle test</code>.</li>
<li>Manually building and running the android-components sample apps to verify that they're still working.</li>
</ul>
<p>Ideally some or all of this would be automated and run in CI, but we have not yet invested in such automation.</p>
<h2 id="test-coverage"><a class="header" href="#test-coverage">Test Coverage</a></h2>
<p>We currently have code coverage reporting on Github using <a href="https://github.com/mozilla/application-services/blob/main/codecov.yml">codecov</a>. However, our code coverage does not tell us how much more coverage is caused by our consumers' tests.</p>
<h2 id="ideas-for-improvement"><a class="header" href="#ideas-for-improvement">Ideas for Improvement</a></h2>
<ul>
<li>ASan, Memsan, and maybe other sanitizer checks, especially around the points where we cross FFI boundaries.</li>
<li>General-purpose fuzzing, such as via https://github.com/jakubadamw/arbitrary-model-tests</li>
<li>We could consider making a mocking backend for viaduct, which would also be mockable from Kotlin/Swift.</li>
<li>Add more end-to-end integration tests!</li>
<li>Live device tests, e.g. actual Fenixes running in an emulator and syncing to each other.</li>
<li>Run consumer integration tests in CI against main.</li>
</ul>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/application-services/edit/main/docs/howtos/testing-a-rust-component.md">Edit this file on GitHub.</a></footer><div style="break-before: page; page-break-before: always;"></div><h1 id="smoke-testing-application-services-against-end-user-apps"><a class="header" href="#smoke-testing-application-services-against-end-user-apps">Smoke testing Application Services against end-user apps</a></h1>
<p>This is a great way of finding integration bugs with <code>application-services</code>.
The testing can be done manually using substitution scripts, but we also have scripts that will do the smoke-testing for you.</p>
<h2 id="firefox-ios"><a class="header" href="#firefox-ios">Firefox iOS</a></h2>
<p>The <code>automation/smoke-test-firefox-ios.py</code> script will clone (or use a local version) of Firefox iOS and
run tests against the current application-services worktree.<br />
Add the <code>-h</code> argument to discover all of the script's exciting options!</p>
<h2 id="android-components"><a class="header" href="#android-components">Android Components</a></h2>
<p>The <code>automation/smoke-test-android-components.py</code> script will clone (or use a local version) of
android-components and run a subset of its tests against the current <code>application-services</code> worktree.
It tries to only run tests that might be relevant to <code>application-services</code> functionality.</p>
<h2 id="fenix"><a class="header" href="#fenix">Fenix</a></h2>
<p>The <code>automation/smoke-test-fenix.py</code> script will clone (or use a local version) of Fenix and
run tests against the current <code>application-services</code> worktree.</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/application-services/edit/main/docs/howtos/smoke-testing-app-services.md">Edit this file on GitHub.</a></footer><div style="break-before: page; page-break-before: always;"></div><h1 id="testing-faster-how-to-avoid-making-compile-times-worse-by-adding-tests"><a class="header" href="#testing-faster-how-to-avoid-making-compile-times-worse-by-adding-tests">Testing faster: How to avoid making compile times worse by adding tests</a></h1>
<h2 id="background"><a class="header" href="#background">Background</a></h2>
<p>We'd like to keep <code>cargo test</code>, <code>cargo build</code>, <code>cargo check</code>, ... reasonably
fast, and we'd <em>really</em> like to keep them fast if you pass <code>-p</code> for a specific
project. Unfortunately, there are a few ways this can become unexpectedly slow.
The easiest of these problems for us to combat at the moment is the unfortunate
placement of dev-dependencies in our build graph.</p>
<p>If you perform a <code>cargo test -p foo</code>, all dev-dependencies of <code>foo</code> must be
compiled before <code>foo</code>'s tests can start. This includes dependencies only used
non-test targets, such as examples or benchmarks.</p>
<p>In an ideal world, cargo could run your tests as soon as it finished with the
dependencies it needs for those tests, instead of waiting for your benchmark
suite, or the arg-parser your examples use, or etc.</p>
<p>Unfortunately, all cargo knows is that these are <code>dev-dependencies</code>, and not
which targets actually use them.</p>
<p>Additionally, unqualified invocations of cargo (that is, without <code>-p</code>) might
have an even worse time if we aren't careful. If I run, <code>cargo test</code>, cargo
knows <em>every</em> crate in the workspace needs to be built with all dev
dependencies, if <code>places</code> depends on <code>fxa-client</code>, all of <code>fxa-clients</code>
dev-dependencies must be compiled, ready, and linked in at least to the <code>lib</code>
target before we can even think about starting on <code>places</code>.</p>
<p>We have not been careful about what shape the dependency graph ends up as when example code is
taken into consideration (as it is by cargo during certain builds), and as a
result, we have this problem. Which isn't really a problem we
want to fix: Example code can and should depend on several different components,
and use them together in interesting ways.</p>
<p>So, because we don't want to change what our examples do, or make
major architectural changes of the non-test code for something like this, we
need to do something else.</p>
<h2 id="the-solution"><a class="header" href="#the-solution">The Solution</a></h2>
<p>To fix this, we manually insert &quot;cuts&quot; into the dependency graph to help cargo
out. That is, we pull some of these build targets (e.g. examples, benchmarks,
tests if they cause a substantial compile overhead) into their own dedicated
crates so that:</p>
<ol>
<li>They can be built in parallel with each other.</li>
<li>Crates depending on the component itself are not waiting on the
test/bench/example build in order for their test build to begin.</li>
<li>A potentially smaller set of our crates need to be rebuilt -- and a smaller
set of possible configurations exist meaning fewer items to add pressure to
caches.</li>
<li>...</li>
</ol>
<p>Some rules of thumb for when / when not to do this:</p>
<ul>
<li>
<p>All rust examples should be put in <code>examples/*</code>.</p>
</li>
<li>
<p>All rust benchmarks should be put in <code>testing/separated/*</code>. See the section
below on how to set your benchmark up to avoid redundant compiles.</p>
</li>
<li>
<p>Rust tests which brings in heavyweight dependencies should be evaluated on an
ad-hoc basis. If you're concerned, measure how long compilation takes
with/without, and consider how many crates depend on the crate where the test
lives (e.g. a slow test in support/foo might be far worse than one in a leaf
crate), etc...</p>
</li>
</ul>
<h3 id="appendix-how-to-avoid-redundant-compiles-for-benchmarks-and-integration-tests"><a class="header" href="#appendix-how-to-avoid-redundant-compiles-for-benchmarks-and-integration-tests">Appendix: How to avoid redundant compiles for benchmarks and integration tests</a></h3>
<p>To be clear, this is way more important for benchmarks (which always compile as
release and have a costly link phase).</p>
<p>Say you have a directory structure like the following:</p>
<pre><code>mycrate
 ├── src
 │   └── lib.rs
 | ...
 ├── benches
 │   ├── bench0.rs
 |   ├── bench1.rs
 │   └── bench2.rs
 ├── tests
 │   ├── test0.rs
 |   ├── test1.rs
 │   └── test2.rs
 └── ...
</code></pre>
<p>When you run your integration tests or benchmarks, each of <code>test0</code>, <code>test1</code>,
<code>test2</code> or <code>bench0</code>, <code>bench1</code>, <code>bench2</code> is compiled as it's own crate that runs
the tests in question and exits.</p>
<p>That means 3 benchmark executables are built on release settings, and 3
integration test executables.</p>
<p>If you've ever tried to add a piece of shared utility code into your integration
tests, only to have cargo (falsely) complain that it is dead code: this is why.
Even if <code>test0.rs</code> and <code>test2.rs</code> <em>both</em> use the utility function, unless
<em>every</em> test crate uses <em>every</em> shared utility, the crate that doesn't will
complain.</p>
<p>(Aside: This turns out to be an unintentional secondary benefit of this approach
-- easier shared code among tests, without having to put a
<code>#![allow(dead_code)]</code> in your utils.rs. We haven't hit that very much here,
since we tend to stick to unit tests, but it came up in mentat several times,
and is a frequent complaint people have)</p>
<p>Anyway, the solution here is simple: Create a new crate. If you were working in
<code>components/mycrate</code> and you want to add some integration tests or benchmarks,
you should do <code>cargo new --lib testing/separated/mycrate-test</code> (or
<code>.../mycrate-bench</code>).</p>
<p>Delete <code>.../mycrate-test/src/lib.rs</code>. Yep, really, we're making a crate that
only has integration tests/benchmarks (See the &quot;FAQ0&quot; section at the bottom of
the file if you're getting incredulous).</p>
<p>Now, add a <code>src/tests.rs</code> or a <code>src/benches.rs</code>. This file should contain <code>mod foo;</code> declarations for each submodule containing tests/benchmarks, if any.</p>
<p>For benches, this is also where you set up the benchmark harness (refer to
benchmark library docs for how).</p>
<p>Now, for a test, add: into your Cargo.toml</p>
<pre><code class="language-toml">[[test]]
name = &quot;mycrate-test&quot;
path = &quot;src/tests.rs&quot;
</code></pre>
<p>and for a benchmark, add:</p>
<pre><code class="language-toml">[[test]]
name = &quot;mycrate-benches&quot;
path = &quot;src/benches.rs&quot;
harness = false
</code></pre>
<p>Because we aren't using <code>src/lib.rs</code>, this is what declares which file is the
root of the test/benchmark crate. Because there's only one target (unlike with
<code>tests/*</code> / <code>benches/*</code> under default settings), this will compile more quickly.</p>
<p>Additionally, <code>src/tests.rs</code> and <code>src/benches.rs</code> will behave like a normal
crate, the only difference being that they don't produce a lib, and that they're
triggered by <code>cargo test</code>/<code>cargo run</code> respectively.</p>
<h3 id="faq0-why-put-testsbenches-in-src-instead-of-disabling-autotestsautobenches"><a class="header" href="#faq0-why-put-testsbenches-in-src-instead-of-disabling-autotestsautobenches">FAQ0: Why put tests/benches in <code>src/*</code> instead of disabling <code>autotests</code>/<code>autobenches</code></a></h3>
<p>Instead of putting tests/benchmarks inside <code>src</code>, we could just delete the <code>src</code>
dir outright, and place everything in <code>tests</code>/<code>benches</code>.</p>
<p>Then, to get the same one-rebuild-per-file behavior that we'll get in <code>src</code>, we
need to add <code>autotests = false</code> or <code>autobenches = false</code> to our Cargo.toml,
adding a root <code>tests/tests.rs</code> (or <code>benches/benches.rs</code>) containing <code>mod</code> decls
for all submodules, and finally by referencing that &quot;root&quot; in the Cargo.toml
<code>[[tests]]</code> / <code>[[benches]]</code> list, exactly the same way we did for using <code>src/*</code>.</p>
<p>This would work, and on the surface, using <code>tests/*.rs</code> and <code>benches/*.rs</code> seems
more consistent, so it seems weird to use <code>src/*.rs</code> for these files.</p>
<p>My reasoning is as follows: Almost universally, <code>tests/*.rs</code>, <code>examples/*.rs, </code>benches/*.rs`, etc. are automatic. If you add a test into the tests folder, it
will run without anything else.</p>
<p>If we're going to set up one-build-per-{test,bench}suite as I described, this
fundamentally cannot be true. In this paradigm, if you add a test file named
<code>blah.rs</code>, you must add a <code>mod blah</code> it to the parent module.</p>
<p>It seems both confusing and error-prone to use <code>tests/*</code>, but have it behave
that way, however this is absolutely the normal behavior for files in <code>src/*.rs</code>
-- When you add a file, you then need to add it to it's parent module, and this
is something Rust programmers are pretty used to.</p>
<p>(In fact, we even replicated this behavior (for no reason) in the places
integration tests, and added the <code>mod</code> declarations to a &quot;controlling&quot; parent
module -- It seems weird to be in an environment where this <em>isn't</em> required)</p>
<p>So, that's why. This way, we make it <em>way</em> less likely that you add a test file
to some directory, and have it get ignored because you didn't realize that in
this one folder, you need to add a <code>mod mytest</code> into a neighboring tests.rs.</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/application-services/edit/main/docs/design/test-faster.md">Edit this file on GitHub.</a></footer><div style="break-before: page; page-break-before: always;"></div><h1 id="dependency-management-guidelines"><a class="header" href="#dependency-management-guidelines">Dependency Management Guidelines</a></h1>
<p>This repository uses third-party code from a variety of sources, so we need to be mindful
of how these dependencies will affect our consumers.  Considerations include:</p>
<ul>
<li>General code quality.</li>
<li><a href="https://www.mozilla.org/en-US/MPL/license-policy/#Licenses_Compatible_with_the_MPL">Licensing compatibility</a>.</li>
<li>Handling of security vulnerabilities.</li>
<li>The potential for <a href="https://medium.com/intrinsic/compromised-npm-package-event-stream-d47d08605502">supply-chain compromise</a>.</li>
</ul>
<p>We're still evolving our policies in this area, but these are the
guidelines we've developed so far.</p>
<h2 id="rust-code-1"><a class="header" href="#rust-code-1">Rust Code</a></h2>
<p>Unlike <a href="https://firefox-source-docs.mozilla.org/build/buildsystem/rust.html">Firefox</a>,
we do not vendor third-party source code directly into the repository.  Instead we rely on
<code>Cargo.lock</code> and its hash validation to ensure that each build uses an identical copy
of all third-party crates.  These are the measures we use for ongoing maintence of our
existing dependencies:</p>
<ul>
<li>Check <code>Cargo.lock</code> into the repository.</li>
<li>Generate built artifacts using the <code>--locked</code> flag to <code>cargo build</code>, as an additional
assurance that the existing <code>Cargo.lock</code> will be respected.</li>
<li>Regularly run <a href="https://github.com/RustSec/cargo-audit">cargo-audit</a> in CI to alert us to
security problems in our dependencies.
<ul>
<li>It runs on every PR, and once per hour on the <code>main</code> branch</li>
</ul>
</li>
<li>Use <a href="https://github.com/mozilla/application-services/blob/main/tools/dependency_summary.py">a home-grown tool</a> to generate a summary of dependency licenses
and to check them for compatibility with MPL-2.0.
<ul>
<li>Check these summaries into the repository and have CI alert on unexpected changes,
to guard against pulling in new versions of a dependency under a different license.</li>
</ul>
</li>
</ul>
<p>Adding a new dependency, whether we like it or not, is a big deal - that dependency and everything
it brings with it will become part of Firefox-branded products that we ship to end users.
We try to balance this responsibility against the many benefits of using existing code, as follows:</p>
<ul>
<li>In general, be conservative in adding new third-party dependencies.
<ul>
<li>For trivial functionality, consider just writing it yourself.
Remember the cautionary tale of <a href="https://www.theregister.co.uk/2016/03/23/npm_left_pad_chaos/">left-pad</a>.</li>
<li>Check if we already have a crate in our dependency tree that can provide the needed functionality.</li>
</ul>
</li>
<li>Prefer crates that have a a high level of due-dilligence already applied, such as:
<ul>
<li>Crates that are <a href="https://dxr.mozilla.org/mozilla-central/source/third_party/rust">already vendored into Firefox</a>.</li>
<li>Crates from <a href="https://github.com/rust-lang-nursery">rust-lang-nursery</a>.</li>
<li>Crates that appear to be widely used in the rust community.</li>
</ul>
</li>
<li>Check that it is clearly licensed and is <a href="https://www.mozilla.org/en-US/MPL/license-policy/#Licenses_Compatible_with_the_MPL">MPL-2.0 compatible</a>.</li>
<li>Take the time to investigate the crate's source and ensure it is suitably high-quality.
<ul>
<li>Be especially wary of uses of <code>unsafe</code>, or of code that is unusually resource-intensive to build.</li>
<li>Dev dependencies do not require as much scrutiny as dependencies that will ship in consuming applications,
but should still be given some thought.
<ul>
<li>There is still the potential for supply-chain compromise with dev dependencies!</li>
</ul>
</li>
</ul>
</li>
<li>As part of the PR that introduces the new dependency:
<ul>
<li>Regenerate dependency summary files using the <a href="https://github.com/mozilla/application-services/blob/main/tools/regenerate_dependency_summaries.sh">regenerate_dependency_summaries.sh</a>.</li>
<li>Explicitly describe your consideration of the above points.</li>
</ul>
</li>
</ul>
<p>Updating to new versions of existing dependencies is a normal part of software development
and is not accompanied by any particular ceremony.</p>
<h2 id="androidkotlin-code"><a class="header" href="#androidkotlin-code">Android/Kotlin Code</a></h2>
<p>We currently depend only on the following Kotlin dependencies:</p>
<ul>
<li><a href="https://github.com/java-native-access/jna">JNA</a></li>
<li><a href="https://github.com/google/protobuf-gradle-plugin">protobuf-gradle-plugin</a></li>
</ul>
<p>We currently depend on the following <strong>developer</strong> dependencies in the Kotlin codebase,
but they do not get included in built distribution files:</p>
<ul>
<li>detekt</li>
<li>ktlint</li>
</ul>
<p>No additional Kotlin dependencies should be added to the project unless absolutely necessary.</p>
<h2 id="iosswift-code"><a class="header" href="#iosswift-code">iOS/Swift Code</a></h2>
<p>We currently depend only on the <a href="https://github.com/mozilla/application-services/blob/main/Cartfile">following dependencies</a>:</p>
<ul>
<li><a href="https://github.com/apple/swift-protobuf">swift-protobuf</a></li>
<li><a href="https://github.com/jrendel/SwiftKeychainWrapper/">SwiftKeychainWrapper</a></li>
</ul>
<p>No additional Swift dependencies should be added to the project unless absolutely necessary.</p>
<h2 id="other-code"><a class="header" href="#other-code">Other Code</a></h2>
<p>We currently depend on local builds of the following system dependencies:</p>
<ul>
<li><a href="https://hg.mozilla.org/projects/nss">NSS</a> and <a href="https://hg.mozilla.org/projects/nspr">NSPR</a></li>
<li><a href="https://github.com/sqlcipher/sqlcipher">SQLCipher</a></li>
<li><a href="https://github.com/protocolbuffers/protobuf">Protobuf</a></li>
</ul>
<p>No additional system dependencies should be added to the project unless absolutely necessary.</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/application-services/edit/main/docs/dependency-management.md">Edit this file on GitHub.</a></footer><div style="break-before: page; page-break-before: always;"></div><h1 id="adding-a-new-component-to-application-services"><a class="header" href="#adding-a-new-component-to-application-services">Adding a new component to Application Services</a></h1>
<p>Each component in the Application Services repository has three parts (the Rust code,
the Kotlin wrapper, and the Swift wrapper) so there are quite a few moving
parts involved in adding a new component. This is a rapid-fire list of all
the things you'll need to do if adding a new component from scratch.</p>
<h2 id="the-rust-code"><a class="header" href="#the-rust-code">The Rust Code</a></h2>
<p>Your component should live under <code>./components</code> in this repo.
Use <code>cargo new --lib ./components/&lt;your_crate_name&gt;</code>to create a new library crate,
and please try to avoid using hyphens in the crate name.</p>
<p>See the <a href="howtos/./building-a-rust-component.html">Guide to Building a Rust Component</a> for general
advice on designing and structuring the actual Rust code, and follow the
<a href="howtos/../dependency-management.html">Dependency Management Guidelines</a> if your crate
introduces any new dependencies.</p>
<p>Use <a href="https://mozilla.github.io/uniffi-rs/">UniFFI</a> to define how your crate's
API will get exposed to foreign-language bindings. By convention, put the interface
definition file at <code>./components/&lt;your_crate_name&gt;/&lt;your_crate_name&gt;.udl</code>. Use
the <code>builtin-bindgen</code> feature of UniFFI to simplify the build process, by
putting the following in your <code>Cargo.toml</code>:</p>
<pre><code>[build-dependencies]
uniffi_build = { version = &quot;&lt;latest version here&gt;&quot;, features=[&quot;builtin-bindgen&quot;] }
</code></pre>
<p>Include your new crate in the <code>application-services</code> workspace, by adding
it to the <code>members</code> and <code>default-members</code> lists in the <code>Cargo.toml</code> at
the root of the repository.</p>
<p>In order to be published to consumers, your crate must be included in the
<a href="howtos/../design/megazords.html">&quot;megazord&quot;</a> crate for each target platform:</p>
<ul>
<li>For Android, add it as a dependency in <code>./megazords/full/Cargo.toml</code> and
add a <code>pub use &lt;your_crate_name&gt;</code> to <code>./megazords/full/src/lib.rs</code>.</li>
<li>For iOS, add it as a dependency in <code>./megazords/ios-rust/rust/Cargo.toml</code> and
add a <code>pub use &lt;your_crate_name&gt;</code> to <code>./megazords/ios-rust/src/lib.rs</code>.</li>
</ul>
<p>Run <code>cargo check -p &lt;your_crate_name&gt;</code> in the repository root to confirm that
things are configured properly. This will also have the side-effect of updating
<code>Cargo.lock</code> to contain your new crate and its dependencies.</p>
<h2 id="the-kotlin-bindings"><a class="header" href="#the-kotlin-bindings">The Kotlin Bindings</a></h2>
<p>Make a <code>./components/&lt;your_crate_name&gt;/android</code> subdirectory to contain
Kotlin- and Android-specific code. This directory will contain a gradle
project for building your Kotlin bindings.</p>
<p>Copy the <code>build.gradle</code> file from <code>./components/crashtest/android/</code> into
your own component's directory, and edit it to replace the references to
<code>crashtest.udl</code> with your own component's <code>.udl</code> file.</p>
<p>Create a file <code>./components/&lt;your_crate_name&gt;/uniffi.toml</code> with the
following contents:</p>
<pre><code class="language-toml">[bindings.kotlin]
package_name = &quot;mozilla.appservices.&lt;your_crate_name&gt;&quot;
cdylib_name = &quot;megazord&quot;
</code></pre>
<p>Create a file <code>./components/&lt;your_crate_name&gt;/android/src/main/AndroidManifest.xml</code>
with the following contents:</p>
<pre><code class="language-xml">&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    package=&quot;org.mozilla.appservices.&lt;your_crate_name&gt;&quot; /&gt;
</code></pre>
<p>In the root of the repository, edit <code>.buildconfig-android.yml</code>to add
your component's metadata. This will cause it to be included in the
gradle workspace and in our build and publish pipeline. Check whether
it builds correctly by running:</p>
<ul>
<li><code>./gradlew &lt;your_crate_name&gt;:assembleDebug</code></li>
</ul>
<p>You can include hand-written Kotlin code alongside the automatically
generated bindings, by placing `.kt`` files in a directory named:</p>
<ul>
<li><code>./android/src/test/java/mozilla/appservices/&lt;your_crate_name&gt;/</code></li>
</ul>
<p>You can write Kotlin-level tests that consume your component's API,
by placing `.kt`` files in a directory named:</p>
<ul>
<li><code>./android/src/test/java/mozilla/appservices/&lt;your_crate_name&gt;/</code>.</li>
</ul>
<p>So you would end up with a directory structure something like this:</p>
<ul>
<li><code>components/&lt;your_crate_name&gt;/</code>
<ul>
<li><code>Cargo.toml</code></li>
<li><code>uniffi.toml</code></li>
<li><code>src/</code>
<ul>
<li>Rust code here.</li>
</ul>
</li>
<li><code>android/</code>
<ul>
<li><code>build.gradle</code></li>
<li><code>src/</code>
<ul>
<li><code>main/</code>
<ul>
<li><code>AndroidManifest.xml</code></li>
<li><code>java/mozilla/appservices/&lt;your_crate_name&gt;/</code>
<ul>
<li>Hand-written Kotlin code here.</li>
</ul>
</li>
</ul>
</li>
<li><code>test/java/mozilla/appservices/&lt;your_crate_name&gt;/</code>
<ul>
<li>Kotlin test-cases here.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Run your component's Kotlin tests with <code>./gradlew &lt;your_crate_name&gt;:test</code>
to confirm that this is all working correctly.</p>
<h2 id="the-swift-bindings"><a class="header" href="#the-swift-bindings">The Swift Bindings</a></h2>
<h3 id="creating-the-directory-structure"><a class="header" href="#creating-the-directory-structure">Creating the directory structure</a></h3>
<p>Make a <code>./components/&lt;your_crate_name&gt;/ios</code> subdirectory to contain
Swift- and iOS-specific code. The UniFFI-generated swift bindings will
be written to a subdirectory named <code>Generated</code>.</p>
<p>You can include hand-written Swift code alongside the automatically
generated bindings, by placing <code>.swift</code> files in a directory named:
<code>./ios/&lt;your_crate_name&gt;/</code>.</p>
<p>So you would end up with a directory structure something like this:</p>
<ul>
<li><code>components/&lt;your_crate_name&gt;/</code>
<ul>
<li><code>Cargo.toml</code></li>
<li><code>uniffi.toml</code></li>
<li><code>src/</code>
<ul>
<li>Rust code here.</li>
</ul>
</li>
<li><code>ios/</code>
<ul>
<li><code>&lt;your_crate_name&gt;/</code>
<ul>
<li>Hand-written Swift code here.</li>
</ul>
</li>
<li><code>Generated/</code>
<ul>
<li>Generated Swift code will be written into this directory.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="adding-your-component-to-the-carthage-megazord"><a class="header" href="#adding-your-component-to-the-carthage-megazord">Adding your component to the Carthage Megazord</a></h3>
<blockquote>
<p><strong>NOTE</strong> <em>We are close to removing Carthage support completely from our repository. For any new components please move on to the next section on adding your component to the <a href="howtos/adding-a-new-component.html#including-the-component-in-the-swift-package-manager-megazord">Swift Package Manager megazord</a>.</em></p>
</blockquote>
<p>Edit <code>megazords/ios/MozillaAppServices.h</code> and add an import line for your component,
like:</p>
<pre><code>#import &quot;&lt;your_crate_name&gt;FFI.h&quot;
</code></pre>
<p>You will then need to add your component into the iOS <a href="howtos/../design/megazords.html">&quot;megazord&quot;</a>
XCode project, which can only really by done using the XCode application,
which can only really be done if you're on a Mac.</p>
<p>Open <code>megazords/ios/MozillaAppServices.xcodeproj</code> in XCode.</p>
<p>In the Project navigator, add a new Group for your new component, pointing to
the <code>./ios/</code> directory you created above. Add the following entries to the Group:</p>
<ul>
<li>The <code>.udl</code> file for you component, from <code>../src/&lt;your_crate_name&gt;.udl</code>.</li>
<li>Any hand-written <code>.swift </code>files for your component</li>
<li>A sub-group named &quot;Generated&quot;, pointing to the <code>./Generated/</code> subdirectory, and
containing entries for the files generated by UniFFI:
<ul>
<li><code>&lt;your_crate_name&gt;.swift</code></li>
<li><code>&lt;your_crate_name&gt;FFI.h</code></li>
</ul>
</li>
</ul>
<p>The result should look something like this:</p>
<p><img src="howtos/./img/xcode_add_component_1.png" alt="Screenshot of XCode Project Navigator" /></p>
<p>Click on the top-level &quot;MozillaAppServices&quot; project in the navigator,
then go to &quot;Build Phases&quot; and add <code>&lt;your_crate_name&gt;.udl</code> to the list
of &quot;Compile Sources&quot;. This will trigger an XCode Build Rule that generates
the Swift bindings automatically. Also include any hand-written <code>.swift</code> files
in this list.</p>
<p>The result should look something like this:</p>
<p><img src="howtos/./img/xcode_add_component_2.png" alt="Screenshot of XCode Compile Sources list" /></p>
<p>In the same &quot;Build Phases&quot; screen, under the &quot;Headers&quot; section, add <code>&lt;your_crate_name&gt;FFI.h</code> to the list of Public headers.
The result should look something like this:</p>
<p><img src="howtos/./img/xcode_add_component_3.png" alt="Screenshot of XCode Headers list" /></p>
<p>Build the project in XCode to check whether that all worked correctly.</p>
<p>To add Swift tests for your component API, create them in a file under
<code>megazords/ios/MozillaAppServicesTests/</code>. Use this syntax to import
your component's bindings from the compiled megazord:</p>
<pre><code>@testable import MozillaAppServices
</code></pre>
<p>In XCode, navigate to the <code>MozillaAppServicesTests</code> Group and add your
new test file as an entry. Select the corresponding target, click on
&quot;Build Phases&quot;, and add your test file to the list of &quot;Compile Sources&quot;.
The result should look something like this:</p>
<p><img src="howtos/./img/xcode_add_component_4.png" alt="Screenshot of XCode Test Setup" /></p>
<p>Use the XCode Test Navigator to run your tests and check whether
they're passing.</p>
<h3 id="including-the-component-in-the-swift-package-manager-megazord"><a class="header" href="#including-the-component-in-the-swift-package-manager-megazord">Including the component in the Swift Package Manager megazord</a></h3>
<blockquote>
<p><em>For more information on our Swift Package Manager design, check the <a href="howtos/../adr/0003-swift-packaging.html">ADR that introduced the Swift Package Manager</a></em></p>
</blockquote>
<p>You will need to do the following steps to include the component in the megazord:</p>
<ol>
<li>Update its <code>uniffi.toml</code> to include the following settings:
<code>toml [bindings.swift] ffi_module_name = &quot;MozillaRustComponents&quot; ffi_module_filename = &quot;&lt;crate_name&gt;FFI&quot; </code></li>
<li>Add the component as a dependency to the <code>Cargo.toml</code> in <a href="https://github.com/mozilla/application-services/blob/main/megazords/ios-rust/Cargo.toml"><code>megazords/ios-rust/</code></a></li>
<li>Add a <code>pub use</code> declaration for the component in <a href="https://github.com/mozilla/application-services/blob/main/megazords/ios-rust/src/lib.rs"><code>megazords/ios-rust/src/lib.rs</code></a></li>
<li>Add logic to the <a href="https://github.com/mozilla/application-services/blob/main/megazords/ios-rust/build-xcframework.sh"><code>megazords/ios-rust/build-xcframework.sh</code></a> to copy or generate its header file into the build</li>
<li>Add an <code>#import</code> for its header file to <a href="https://github.com/mozilla/application-services/blob/main/megazords/ios-rust/MozillaRustComponents.h"><code>megazords/ios-rust/MozillaRustComponents.h</code></a> </li>
</ol>
<h3 id="distribute-your-component-with-rust-components-swift"><a class="header" href="#distribute-your-component-with-rust-components-swift">Distribute your component with <code>rust-components-swift</code></a></h3>
<p>To distribute your component with <code>rust-components-swift</code> follow the following steps:</p>
<ol>
<li>Add logic for dynamically generating any swift code to the <a href="https://github.com/mozilla/rust-components-swift/blob/main/generate.sh"><code>generate.sh</code> script in the <code>rust-components-swift</code> repo</a>. You can use that script to generate:
<ul>
<li><code>uniffi</code> bindings</li>
<li><code>Glean</code> metrics</li>
</ul>
</li>
<li>Edit the <a href="https://github.com/mozilla/rust-components-swift/blob/main/Package.swift"><code>Package.swift</code> in the <code>rust-components-swift</code> repo</a> to add the new component
<ul>
<li>Add a new library product for the component under <code>products</code></li>
<li>Add a corresponding target for the component under <code>targets</code>
<ul>
<li>Make sure it depends on <code>MozillaRustComponentsWrapper</code> to pull in pre-compiled Rust Code, and any third-party Swift Packages it requires.</li>
</ul>
</li>
</ul>
</li>
</ol>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/application-services/edit/main/docs/howtos/adding-a-new-component.md">Edit this file on GitHub.</a></footer><div style="break-before: page; page-break-before: always;"></div><h1 id="guide-to-building-a-syncable-rust-component"><a class="header" href="#guide-to-building-a-syncable-rust-component">Guide to Building a Syncable Rust Component</a></h1>
<blockquote>
<p>This is a guide to creating a new Syncable Rust Component like many of the components in this repo. If you are looking for information how to build (ie,compile, etc) the existing components, you are looking for <a href="howtos/../building.html">our build documentation</a></p>
</blockquote>
<p>Welcome!</p>
<p>It's great that you want to build a Rust Component - this guide should help
get you started. It documents some nomenclature, best-practices and other
tips and tricks to get you started.</p>
<p>This document is just for general guidance - every component will be different
and we are still learning how to make these components. Please update this
document with these learnings.</p>
<p>To repeat with emphasis - <strong>please consider this a living document</strong>.</p>
<h1 id="general-design-and-structure-of-the-component"><a class="header" href="#general-design-and-structure-of-the-component">General design and structure of the component</a></h1>
<p>We think components should be structured as described here.</p>
<h2 id="we-build-libraries-not-frameworks"><a class="header" href="#we-build-libraries-not-frameworks">We build libraries, not frameworks</a></h2>
<p>Think of building a &quot;library&quot;, not a &quot;framework&quot; - the application should be in
control and calling functions exposed by your component, not providing functions
for your component to call.</p>
<h2 id="the-store-is-the-entry-point"><a class="header" href="#the-store-is-the-entry-point">The &quot;store&quot; is the &quot;entry-point&quot;</a></h2>
<p>[Note that some of the older components use the term &quot;store&quot; differently; we
should rename them! In Places, it's called an &quot;API&quot;; in Logins an &quot;engine&quot;. See
<code>webext-storage</code> for a more recent component that uses the term &quot;Store&quot; as we
think it should be used.]</p>
<p>The &quot;Store&quot; is the entry-point for the consuming application - it provides the
core functionality exposed by the component and manages your databases and other
singletons. The responsibilities of the &quot;Store&quot; will include things like creating the
DB if it doesn't exist, doing schema upgrades etc.</p>
<p>The functionality exposed by the &quot;Store&quot; will depend on the complexity of the
API being exposed. For example, for <code>webext-storage</code>, where there are only a
handful of simple public functions, it just directly exposes all the
functionality of the component. However, for Places, which has a much more
complex API, the (logical) Store instead supplies &quot;Connection&quot; instances which
expose the actual functionality.</p>
<h2 id="using-sqlite"><a class="header" href="#using-sqlite">Using sqlite</a></h2>
<p>We prefer sqlite instead of (say) JSON files or RKV.</p>
<p>Always put sqlite into WAL mode, then have exactly 1 writer connection and as
many reader connections you need - which will depend on your use-case - for
example, <code>webext_storage</code> has 1 reader, while <code>places</code> has many.</p>
<p>(Note that places has 2 writers (one for sync, one for the api), but we
believe this was a mistake and should have been able to make things work
better with exactly 1 shared between sync and the api)</p>
<p>We typically have a &quot;DB&quot; abstraction which manages the database itself - the
logic for handling schema upgrades etc and enforcing the &quot;only 1 writer&quot; rule
is done by this.</p>
<p>However, this is just a convenience - the DB abstractions aren't really passed
around - we just pass raw connections (or transactions) around. For example, if
there's a utility function that reads from the DB, it will just have a Rusqlite
connection passed. (Again, older components don't really do this well, but
<code>webext-storage</code> does)</p>
<p>We try and leverage rust to ensure transactions are enforced at the correct
boundaries - for example, functions which write data but which must be done as
part of a transaction will accept a Rusqlite <code>Transaction</code> reference as the
param, whereas something that only reads the Db will accept a Rusqlite
<code>Connection</code> - note that because <code>Transaction</code> supports
<code>Deref&lt;Target = Connection&gt;</code>, you can pass a <code>&amp;Transaction</code> wherever a
<code>&amp;Connection</code> is needed - but not vice-versa.</p>
<h3 id="meta-data"><a class="header" href="#meta-data">Meta-data</a></h3>
<p>You are likely to have a table just for key/value metadata, and this table will
be used by sync (and possibly other parts of the component) to track the
sync IDs, lastModified timestamps etc.</p>
<h3 id="schema-management"><a class="header" href="#schema-management">Schema management</a></h3>
<p>The schemas are stored in the tree in .sql files and pulled into the source at
build time via <code>include_str!</code>. Depending on the complexity of your component,
there may be a need for different Connections to have different Sql (for
example, it may be that only your 'write' connection requires the sql to define
triggers or temp tables, so these might be in their own file.)</p>
<p>Because requirements evolve, there will be a need to support schema upgrades.
This is done by way of sqlite's <code>PRAGMA user_version</code> - which can be thought of
as simple metadata for the database itself. In short, immediately after opening
the database for the first time, we check this version and if it's less than
expected we perform the schema upgrades necessary, then re-write the version
to the new version.</p>
<p>This is easier to read than explain, so read the <code>upgrade()</code> function in
<a href="https://github.com/mozilla/application-services/blob/main/components/places/src/db/schema.rs">the Places schema code</a></p>
<p>You will need to be a big careful here because schema upgrades are going to
block the calling application immediately after they upgrade to a new version,
so if your schema change requires a table scan of a massive table, you are going
to have a bad time. Apart from that though, you are largely free to do whatever
sqlite lets you do!</p>
<p>Note that most of our components have very similar schema and database
management code - these are screaming out to be refactored so common logic can
be shared. Please be brave and have a go at this!</p>
<h3 id="triggers"><a class="header" href="#triggers">Triggers</a></h3>
<p>We tend to like triggers for encompasing application logic - for example, if
updating one row means a row in a different table should be updated based on
that data, we'd tend to prefer an, eg,  <code>AFTER UPDATE</code> trigger than having our
code manually implement the logic.</p>
<p>However, you should take care here, because functionality based on triggers is
difficult to debug (eg, logging in a trigger is difficult) and the functionality
can be difficult to locate (eg, users unfamiliar with the component may wonder
why they can't find certain functionity in the rust code and may not consider
looking in the sqlite triggers)</p>
<p>You should also be careful when creating triggers on persistent main tables.
For example, bumping the change counter isn't a good use for a trigger,
because it'll run for all changes on the table—including those made by Sync.
This means Sync will end up tracking its own changes, and getting into infinite
syncing loops. Triggers on temporary tables, or ones that are used for
bookkeeping where the caller doesn't matter, like bumping the foreign
reference count for a URL, are generally okay.</p>
<h2 id="general-structure-of-the-rust-code"><a class="header" href="#general-structure-of-the-rust-code">General structure of the rust code</a></h2>
<p>We prefer flatter module hierarchies where possible. For example, in <code>Places</code>
we ended up with <code>sync_history</code> and <code>sync_bookmarks</code> sub-modules rather than
a <code>sync</code> submodule itself with <code>history</code> and <code>bookmarks</code>.</p>
<p>Note that the raw connections are never exposed to consumers - for example, they
will tend to be stored as private fields in, eg, a Mutex.</p>
<h1 id="syncing"><a class="header" href="#syncing">Syncing</a></h1>
<p>The traits you need to implement to sync aren't directly covered here.</p>
<p>All meta-data related to sync must be stored in the same database as the
data itself - often in a <code>meta</code> table.</p>
<p>All logic for knowing which records need to be sync must be part of the
application logic, and will often be implemented using <code>triggers</code>. It's quite
common for components to use a &quot;change counter&quot; strategy, which can be
summarized as:</p>
<ul>
<li>
<p>Every table which defines the &quot;top level&quot; items being synced will have a
column called something like 'sync_change_counter' - the app will probably
track this counter manually instead of using a trigger, because sync itself
will need different behavior when it updates the records.</p>
</li>
<li>
<p>At sync time, items with a non-zero change counter are candidates for syncing.</p>
</li>
<li>
<p>As the sync starts, for each item, the current value of the change counter is
remembered. At the end of the sync, the counter is decremented by this value.
Thus, items which were changed between the time the sync started and completed
will be left with a non-zero change counter at the end of the sync.</p>
</li>
</ul>
<h2 id="syncing-faqs"><a class="header" href="#syncing-faqs">Syncing FAQs</a></h2>
<p>This section is stolen from <a href="https://docs.google.com/document/d/1s9ld2F4e83eQ944kN6QXXTRlqrX74w2AJS6W2fDyAJ8">this document</a></p>
<h3 id="whats-the-global-sync-id-and-the-collection-sync-id"><a class="header" href="#whats-the-global-sync-id-and-the-collection-sync-id">What’s the global sync ID and the collection sync ID?</a></h3>
<p>Both guids, both used to identify when the data in the server has changed
radically underneath us (eg, when looking at lastModified is no longer a sane
thing to do.)</p>
<p>The &quot;global sync ID&quot; changing means that every collection needs to be assumed as
having changed radically, whereas just the &quot;collection sync ID&quot; changing means
just that one collection.</p>
<p>These global IDs are most likely to change on a node reassignment (which should
be rare now with durable storage), a password reset, etc. An example of when the
collection ID will change is a &quot;bookmarks restore&quot; - handling an old version of
a database re-appearing is why we store these IDs in the database itself.</p>
<h3 id="whats-get_sync_assoc-why-is-it-important-what-is-storesyncassociation"><a class="header" href="#whats-get_sync_assoc-why-is-it-important-what-is-storesyncassociation">What’s <code>get_sync_assoc</code>, why is it important? What is <code>StoreSyncAssociation</code>?</a></h3>
<p>They are all used to track the guids above. It’s vitally important we know when
these guids change.</p>
<p>StoreSyncAssociation is a simple enum which reflects the state a sync engine
can be in - either <code>Disconnected</code> (ie, we have no idea what the GUIDs are) or
<code>Connected</code> where we know what we think the IDs are (but the server may or may
not match with this)</p>
<p>These GUIDs will typically be stored in the DB in the metadata table.</p>
<h3 id="what-is-apply_incoming-versus-sync_finished"><a class="header" href="#what-is-apply_incoming-versus-sync_finished">what is <code>apply_incoming</code> versus <code>sync_finished</code></a></h3>
<p><code>apply_incoming</code> is where any records incoming from the server (ie, possibly
all records on the server if this is a first-sync, records with a timestamp
later than our last sync otherwise) are processed.</p>
<p><code>sync_finished</code> is where we've done all the sync work other than uploading new
changes to the server.</p>
<h3 id="whats-the-diff-between-reset-and-wipe"><a class="header" href="#whats-the-diff-between-reset-and-wipe">What's the diff between reset and wipe?</a></h3>
<ul>
<li>Reset means “I don’t know what’s on the server - I need to reconcile everything there with everything I have”. IOW, a “first sync”</li>
<li>Wipe means literally “wipe all server data”</li>
</ul>
<h1 id="exposing-to-consumers"><a class="header" href="#exposing-to-consumers">Exposing to consumers</a></h1>
<p>You will need an FFI or some other way of exposing stuff to your consumers.</p>
<p>We are exploring a tool called <a href="https://github.com/mozilla/uniffi-rs/">UniFFI</a> to automatically
generate FFI bindings from the Rust code. It's probably worth a look for your use case, but
is still quite new and may not support everything you need.</p>
<p>If UniFFI doesn't work for you, then you'll need to hand-write the FFI layer.
Here are some earlier blog posts on the topic which might be helpful:</p>
<ul>
<li><a href="https://mozilla.github.io/firefox-browser-architecture/experiments/2017-09-21-rust-on-android.html">Building and Deploying a Rust library on Android</a></li>
<li><a href="https://mozilla.github.io/firefox-browser-architecture/experiments/2017-09-06-rust-on-ios.html">Building and Deploying a Rust library on iOS</a></li>
<li><a href="https://discourse.mozilla.org/t/dear-diary-turns-out-x-platform-is-hard/25348">Blog post re: lessons in binding to Rust code from iOS</a></li>
</ul>
<p>The above are likely to be superseded by uniffi docs, but for now, good luck!</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/application-services/edit/main/docs/howtos/building-a-rust-component.md">Edit this file on GitHub.</a></footer><div style="break-before: page; page-break-before: always;"></div><h1 id="naming-conventions"><a class="header" href="#naming-conventions">Naming Conventions</a></h1>
<p>All names in this project should adhere to the guidelines outlined in this document.</p>
<h2 id="rust-code-2"><a class="header" href="#rust-code-2">Rust Code</a></h2>
<p>TL;DR: do what Rust's builtin warnings and clippy lints tell you
(and CI will fail if there are any unresolved warnings or clippy lints).</p>
<h3 id="overview"><a class="header" href="#overview">Overview</a></h3>
<ul>
<li>
<p>All variable names, function names, module names, and macros in Rust code should follow typical <code>snake_case</code> conventions. </p>
</li>
<li>
<p>All Rust types, traits, structs, and enum variants must follow <code>UpperCamelCase</code>. </p>
</li>
<li>
<p>Static and constant variables should be written in <code>SCREAMING_SNAKE_CASE</code>. s</p>
</li>
</ul>
<p>For more in-depth Rust conventions, see the <a href="https://doc.rust-lang.org/1.0.0/style/style/naming/README.html">Rust Style Guide</a>.</p>
<h3 id="examples"><a class="header" href="#examples">Examples:</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn sync15_passwords_get_all()
struct PushConfiguration{...}
const COMMON_SQL
<span class="boring">}
</span></code></pre></pre>
<h2 id="swift-code-1"><a class="header" href="#swift-code-1">Swift Code</a></h2>
<h3 id="overview-1"><a class="header" href="#overview-1">Overview</a></h3>
<ul>
<li>
<p>Names of types and protocols are <code>UpperCamelCase</code>.</p>
</li>
<li>
<p>All other uses are <code>lowerCamelCase</code>.</p>
</li>
</ul>
<p>For more in-depth Swift conventions, check out the <a href="https://swift.org/documentation/api-design-guidelines/">Swift API Design Guidelines</a>.</p>
<h3 id="examples-1"><a class="header" href="#examples-1">Examples:</a></h3>
<pre><code class="language-swift">enum CheckChildren{...}
func checkTree()
public var syncKey: String
</code></pre>
<h2 id="kotlin-code-1"><a class="header" href="#kotlin-code-1">Kotlin Code</a></h2>
<p>If a source file contains only a top-level class, the source file should reflect the case-sensitive name of the class plus the <em>.kt</em> extension. Otherwise, if the source contains multiple top-level declarations, choose a name that describes the contents of the file, apply <code>UpperCamelCase</code> and append <code>.kt</code> extension.</p>
<h3 id="overview-2"><a class="header" href="#overview-2">Overview</a></h3>
<ul>
<li>
<p>Names of packages are always lower case and do not include underscores. Using multi-word names should be avoided. However, if used, they should be concatenated or use <code>lowerCamelCase</code>.</p>
</li>
<li>
<p>Names of classes and objects use <code>UpperCamelCase</code>.</p>
</li>
<li>
<p>Names of functions, properties, and local variables use <code>lowerCamelCase</code>.</p>
</li>
</ul>
<p>For more in-depth Kotlin Conventions, see the <a href="https://kotlinlang.org/docs/reference/coding-conventions.html#naming-rules">Kotlin Style Guide</a>.</p>
<h3 id="examples-2"><a class="header" href="#examples-2">Examples:</a></h3>
<pre><code class="language-kotlin">//FooBar.kt
class FooBar{...}
fun fromJSONString()
package mozilla.appservices.places
</code></pre>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/application-services/edit/main/docs/naming-conventions.md">Edit this file on GitHub.</a></footer><div style="break-before: page; page-break-before: always;"></div><h1 id="converting-an-existing-component-to-use-uniffi"><a class="header" href="#converting-an-existing-component-to-use-uniffi">Converting an existing Component to use UniFFI</a></h1>
<p>When we started building the components in this repo, exposing Rust code to
Kotlin and Swift was a manual process and each component had its own
hand-written FFI layer and foreign-language bindings.</p>
<p>As we've gained more experience with building components in this way, we've
started to automate bindings generation and capture best practices in a
tool called <a href="https://mozilla.github.io/uniffi-rs/">UniFFI</a>, which is the
currently recommended approach when <a href="howtos/./adding-a-new-component.html">adding a new component from scratch</a>.</p>
<p>We expect that existing components will gradually be ported over to use
UniFFI, and this document is a guide to doing that port.</p>
<h2 id="first-get-familiar-with-uniffi"><a class="header" href="#first-get-familiar-with-uniffi">First, get familiar with UniFFI</a></h2>
<p>First, make sure you've perused the <a href="https://mozilla.github.io/uniffi-rs/">UniFFI guide</a>
to understand the overall architecture of a UniFFI component, and take a look
at the <a href="howtos/./adding-a-new-component.html">guide to adding a new component</a> to understand
how such components fit in to this repo. The aim of porting will be to have a component
that looks like it was added by the process described therein.</p>
<h2 id="next-get-familiar-with-the-target-component"><a class="header" href="#next-get-familiar-with-the-target-component">Next, get familiar with the target component</a></h2>
<p>Pre-UniFFI components typically consist of four main parts:</p>
<ul>
<li>A Rust crate implementing the core functionality of the component</li>
<li>A separate Rust crate that exposes the core functionality over a C-style FFI.</li>
<li>An Android package that imports the C-style FFI into idiomatic Kotlin.</li>
<li>A Swift module that imports the C-style FFI into idiomatic Swift.</li>
</ul>
<p>The code for these parts will be laid out something like this:</p>
<ul>
<li><code>components/&lt;component_name&gt;/</code>
<ul>
<li><code>Cargo.toml</code></li>
<li><code>src/</code>
<ul>
<li>Rust code for the core functionality of the component goes here.</li>
</ul>
</li>
<li><code>ffi/</code>
<ul>
<li><code>Cargo.toml</code></li>
<li><code>src/</code>
<ul>
<li>Rust code specifically for exposing the C-style FFI goes here.</li>
</ul>
</li>
</ul>
</li>
<li><code>android/</code>
<ul>
<li><code>build.gradle</code></li>
<li><code>src/</code>
<ul>
<li><code>main/</code>
<ul>
<li><code>AndroidManifest.xml</code></li>
<li><code>java/mozilla/appservices/&lt;component_name&gt;/</code>
<ul>
<li><code>Lib&lt;ComponentName&gt;FFI.kt</code> (low-level bindings to the C-style FFI)</li>
<li>Higher-level hand-written Kotlin that wraps the FFI.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>ios/</code>
<ul>
<li><code>&lt;component_name&gt;/</code>
<ul>
<li><code>Rust&lt;ComponentName&gt;API.h</code> (low-level bindings to the C-style FFI)</li>
<li>Higher-level hand-written Swift that wraps the FFI.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>The goal here is to replace much of the hand-written wrapper layers with autogenerated
code:</p>
<ul>
<li>The <code>./ffi/</code> crate will disappear entirely, its work is automated by UniFFI
<ul>
<li>If you still need some hand-written <code>pub extern &quot;C&quot;</code> functions, perhaps to
implement features not currently supported by UniFFI, then they should move
into <code>lib.rs</code> of the main component crate.</li>
</ul>
</li>
<li>The low-level <code>Lib&lt;ComponentName&gt;FFI.kt</code> file will disappear entirely, as will some of the
code that converts it back into nice high-level Kotlin classes and interfaces.
<ul>
<li>Some of the hand-written Kotlin code may remain, if it provides functionality that
cannot be implemented in Rust.</li>
</ul>
</li>
<li>The low-level <code>Rust&lt;ComponentName&gt;API.h</code> file will disappear entirely, as will some of the
code that converts it back into nice high-level Swift classes and interfaces.
<ul>
<li>Some of the hand-written Swift code may remain, if it provides functionality that
cannot be implemented in Rust.</li>
</ul>
</li>
</ul>
<p>You'll aim to end up with a simplified file structure that looks like this:</p>
<ul>
<li><code>components/&lt;component_name&gt;/</code>
<ul>
<li><code>Cargo.toml</code></li>
<li><code>uniffi.toml</code></li>
<li><code>src/</code>
<ul>
<li><code>&lt;component_name&gt;.udl</code> (abstract interface definition)</li>
<li>Rust code here.</li>
</ul>
</li>
<li><code>android/</code>
<ul>
<li><code>build.gradle</code></li>
<li><code>src/</code>
<ul>
<li><code>main/</code>
<ul>
<li><code>AndroidManifest.xml</code></li>
<li><code>java/mozilla/appservices/&lt;component_name&gt;/</code>
<ul>
<li>Optional hand-written Kotlin code here.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>ios/</code>
<ul>
<li><code>&lt;component_name&gt;/</code>
<ul>
<li>Optional hand-written Swift code here.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="write-a-first-draft-of-the-udl-file-for-the-components-interface"><a class="header" href="#write-a-first-draft-of-the-udl-file-for-the-components-interface">Write a first draft of the <code>.udl</code> file for the component's interface</a></h2>
<p>Make sure you've got the <code>uniffi-bindgen</code> command available; <code>cargo install uniffi_bindgen</code> will
ensure you have the latest version.</p>
<p>Create <code>./src/&lt;component_name&gt;.udl</code> and try to describe the intended interface for the component
using <a href="https://mozilla.github.io/uniffi-rs/udl_file_spec.html">UniFFI's interface definition language</a>.
You'll probably need to reverse-engineer it a little bit from the existing hand-written Kotlin and/or
Swift code.</p>
<p>Don't spend too much time on trying to match every minute detail of the existing hand-written API.
There are likely to be small differences between how UniFFI likes to do things and how the hand-written
APIs were structured, and it's in everyone's best long-term interests to just push ahead and update
consumers to accommodate any breaking API changes, rathern than e.g. trying to convince UniFFI to
capitalize enum variant names in the same style that the hand-written code was using.</p>
<p>To check whether the <code>.udl</code> file is syntactically valid, you can use <code>uniffi-bindgen</code> to generate
the Rust FFI scaffolding like so:</p>
<pre><code>uniffi-bindgen scaffolding ./src/&lt;component_name&gt;.udl
</code></pre>
<p>If this succeeds, it will generate a file <code>./src/&lt;component_name&gt;.uniffi.rs</code> with a bunch of
thorny auto-generated Rust code. If it fails, it will likely fail with an inscrutable error message.
Unfortunately the error reporting in UniFFI is currently a known pain point, and it can take a
bit of trial-and-error to identify what part of the file is causing the issue. Sorry :-(</p>
<p>The aim at this point is to ensure that the intended interface of the component can be expressed
in terms that UniFFI understands. Most cases should be supported, but you may find some aspect of
the existing component that is hard to express in UniFFI, perhaps even uncovering new functionality
that needs to be added to UniFFI itself!</p>
<p>The <code>.udl</code> file is definitely a first draft at this point. It is normal and expected to need
to iterate on this file as you port over the underlying Rust code.</p>
<h2 id="restructure-the-rust-code-to-introduce-uniffi"><a class="header" href="#restructure-the-rust-code-to-introduce-uniffi">Restructure the Rust code to introduce UniFFI</a></h2>
<p>You will now restructure the existing Rust crate so that its public API surface
and overall &quot;shape&quot; match what you defined in the <code>.udl</code> file.</p>
<p>Start by deleting the <code>./ffi</code> sub-crate, because you're going to use UniFFI to generate
all of that code. You'll also need to remove it from the workspace in the top-level
<code>Cargo.toml</code> file, as well as change the crates under <code>/megazords</code> to import the core
Rust crate for the component rather than importing the FFI sub-crate.</p>
<p>Add UniFFI to the crate's dependencies and configure its <code>build.rs</code> script to invoke the
UniFFI scaffolding generator, as described in <a href="howtos/adding-a-new-component.html">&quot;adding a new component&quot;</a>.</p>
<p>Now, edit <code>./lib.rs</code> so that it matches the interface defined in the <code>.udl</code> file as closely
as possible. If the <code>.udl</code> has an <code>interface Example</code> then <code>lib.rs</code> should contain a
<code>pub struct Example</code>, if the <code>.udl</code> contains an <code>enum ExampleItem</code> then <code>lib.rs</code> should
contain a <code>pub enum ExampleItem</code>, and so-on.</p>
<p>The details of this step will depend heavily on the specific crate, but some tips include:</p>
<ul>
<li>
<p>You may find it useful to move all of the existing code into a sub-module named <code>internal</code>,
and then make a brand new <code>lib.rs</code> that imports or re-defines just the pieces it needs
in order to implement the interface from the <code>.udl</code> file. The <code>fxa-client</code> crate is an
example of a case where this worked out well, though of course your mileage may vary.</p>
</li>
<li>
<p>If the existing crate contains a file named like <code>&lt;component_name&gt;_msg_types.proto</code>, then
it was using Protocol Buffers to serialize data to pass over the FFI. The message types
defined in the <code>.proto</code> file will need to be converted into <code>dictionary</code> or <code>enum</code> definitions
in your <code>.udl</code> file. See the section below for more details.</p>
</li>
</ul>
<p>As noted above, don't be afraid to accept some API churn during the conversion process.
We're willing to accept some breaking API changes as the cost of getting bindings generated
for free, as long as the core functionality and mental model of the component remain intact.</p>
<p>At this point, in theory the crate should be buildable with UniFFI, although it's likely
to require some iteration to get it all working! Run <code>cargo check</code> to check for any
compilation errors without having to do a full build.</p>
<h3 id="removing-protobuf-messages"><a class="header" href="#removing-protobuf-messages">Removing Protobuf Messages</a></h3>
<p>Passing rich structured data over the FFI is the most complex part of our hand-written bindings,
and was previously done by <a href="https://hacks.mozilla.org/2019/04/crossing-the-rust-ffi-frontier-with-protocol-buffers/">serializing data via Protocol Buffers</a>.
This is something that UniFFI tries to make as simple as possible.</p>
<p>Start by locating the <code>&lt;component_name&gt;_msg_types.proto</code> file for the component. This file defines
the structured messages that can be passed over the FFI, and you should see that they correspond
to various types of structured data that the component wants to receive from, or return to,
the foreign-language code.</p>
<p>Find the places in your <code>.udl</code> interface that correspond to these message types and make sure
that you've got a similarly-shaped <code>dictionary</code> or <code>enum</code> for each one. You should find that
representing this structured data in UDL is simpler than protobuf in many cases - for example
many of our <code>.protobuf</code> files need to use a separate <code>ExampleStructs</code> message in order to
pass a list of <code>ExampleStruct</code> messages over the FFI, but in UniFFI this is represented
directly as <code>sequence&lt;ExampleStruct&gt;</code>.</p>
<p>Find the places in the Rust code that are using these message types to return structured data.
In simple cases, you may be able to directly replace uses of <code>msg_types::ExampleStruct</code> with
the corresponding <code>crate::ExampleStruct</code> from your public API.
For more complex cases, you may find it helpful to define an <code>Into</code> mapping between the
UniFFI dictionary/enum in the crate's public interface, and a more complex struct designed
for internal use.</p>
<p>As noted above, don't be afraid to accept some API churn during this conversion process.</p>
<p>Once you have replaced all uses of the <code>msg_types</code> structs in the Rust code:</p>
<ul>
<li>Delete <code>./src/&lt;component_name&gt;_msg_types.proto</code>.</li>
<li>Delete <code>./src/mozilla.appservices.&lt;component_name&gt;.protobuf.rs</code>, which is generated from the <code>.proto</code> file.</li>
<li>Remote <code>prost</code> and <code>prost-derive</code> from the crate's dependencies.</li>
<li>Delete the crate from the list in <code>/tools/protobuf_files.toml</code>.</li>
</ul>
<p>If you happen to find that you've deleted the last crate from the list in <code>protobuf_files.toml</code>,
congratulations! You've successfully removed protocol buffers from this repo entirely, and should
file a bug to track the complete removal of protobuf from our tooling and dependency chain.</p>
<h2 id="document-the-public-api-in-the-rust-code"><a class="header" href="#document-the-public-api-in-the-rust-code">Document the Public API in the Rust code</a></h2>
<p>Write consumer-facing documentation on the public API in <code>lib.rs</code> using Rust's standard
<a href="https://doc.rust-lang.org/rustdoc/how-to-write-documentation.html">rustdoc</a> conventions
and tools. The <code>fxa-client</code> crate may serve as a good example.</p>
<p>You can view the generated documentation by running:</p>
<pre><code>cargo doc --no-deps --open
</code></pre>
<p>In future, we intend to automatically extract documentation from the Rust code
and make it easily available to consumers of the generated bindings.</p>
<p>(In fact there is some work-in-progress code in <a href="https://github.com/mozilla/uniffi-rs/pull/416">uniffi-rs#416</a>
that can read docs from the Rust code and write them back into the <code>.udl</code> file, which you're
welcome to try out if you're feeling adventurous. But it's just a very hacky prototype.)</p>
<h2 id="set-up-the-kotlin-wrapper"><a class="header" href="#set-up-the-kotlin-wrapper">Set up the Kotlin wrapper</a></h2>
<p>It's easiest to start by removing all of the hand-written Kotlin code under <code>android/src/main/java</code>
and then restoring parts of it later if necessary. Leave the <code>AndroidManifest.xml</code> file and any tests
in place.</p>
<p>Delete the <code>android/build.gradle</code> file and then follow the instructions for <a href="howtos/adding-a-new-component.html#the-kotlin-bindings">adding Kotlin bindings
for a new component</a> to create a new <code>build.gradle</code>
file and a corresponding <code>uniffi.toml</code>.</p>
<p>This should be all that's required to set up UniFFI to build the Kotlin bindings. Try building
the Android package to confirm:</p>
<ul>
<li><code>./gradlew &lt;component_name&gt;:assembleDebug</code></li>
</ul>
<p>The UniFFI-generated Kotlin code will be under <code>./android/build/generated/source/uniffi/</code> and
may be useful for debugging.</p>
<p>If there are existing Kotlin tests for the component, the next step is to get those passing:</p>
<ul>
<li><code>./gradlew &lt;component_name&gt;:test</code></li>
</ul>
<p>As noted above, it is normal and expected for the autogenerated bindings to be subtly different
from the previous hand-written ones. For example, UniFFI insists on using SHOUTY_SNAKE_CASE
variant names in Kotlin enums while the hand-written code may have used CamelCase. Some components
also have small naming differences between the Rust code and the hand-written Kotlin bindings,
which UniFFI will not allow.</p>
<p>If the component had functionality in its Kotlin layer that was not part of the Rust API,
then you'll need to add some hand-written Kotlin code under <code>android/src/main/java</code> to
implement it. The <code>fxa-client</code> component may be a good example here: its Rust layer exposes
a <code>FirefoxAccount</code> struct that the Kotlin code wraps into a <code>PersistedFirefoxAccount</code> class,
adding the ability to set a persistence callback.</p>
<p>Finally, you will need to try out the new bindings with a consuming app. For Kotlin code you should
<a href="howtos/locally-published-components-in-fenix.html">make a local build of android-components and Fenix</a>,
updating them to accomodate any changes in the component's public API.</p>
<h2 id="set-up-the-swift-wrapper"><a class="header" href="#set-up-the-swift-wrapper">Set up the Swift wrapper</a></h2>
<p>It's easiest to start by removing all of the hand-written Swift code under <code>./ios</code> and then
restoring parts of it later if necessary.</p>
<p>Edit <code>/megazords/ios/MozillaAppServices.h</code> to remove any references to <code>Rust&lt;ComponentName&gt;API.h</code>,
replacing them with the UniFFI-generated header file name <code>&lt;component_name&gt;FFI.h</code>.</p>
<p>Open <code>/megazords/ios/MozillaAppServices.xcodeproj</code> in XCode and follow the instructions for
<a href="howtos/adding-a-new-component.html#the-swift-bindings">adding Swift bindings for a new component</a> to
configure XCode to build your UniFFI-generated bindings.</p>
<p>While you are in the XCode Project Navigator, you should also delete any references to
<code>Rust&lt;ComponentName&gt;API.h</code> or to the old hand-written Swift wrappers. (They should be highlighted
in red in the Project Navigator, because the files will be missing from disk after you
deleted them above).</p>
<p>This should be all that's required to set up UniFFI to build the Swift bindings. Try building
the project in XCode to confirm.</p>
<p>The UniFFI-generated Swift code will be under <code>ios/Generated</code> and may be useful for debugging.</p>
<p>If there are existing Swift tests for the component, the next step is to get those passing:</p>
<ul>
<li><code>./automation/run_ios_tests.sh</code></li>
<li>(or run them from the XCode GUI)</li>
</ul>
<p>As noted above, it is normal and expected for the autogenerated bindings to be subtly different
from the previous hand-written ones. Many existing components have small naming differences
between the Rust code and the hand-written Swift bindings, which UniFFI will not allow.</p>
<p>If the component had functionality in its Swift layer that was not part of the Rust API,
then you'll need to add some hand-written Swift code under <code>./ios/&lt;ComponentName&gt;</code> to
implement it. The <code>fxa-client</code> component may be a good example here: its Rust layer exposes
a <code>FirefoxAccount</code> struct that the Swift code wraps into a <code>PersistedFirefoxAccount</code> class,
adding the ability to set a persistence callback.</p>
<p>You will need to add any such file to the &quot;Compile Sources&quot; list in XCode, in the same way
that you added the <code>.udl</code> file.</p>
<p>Finally, you will need to try out the new bindings with a consuming app. For Swift code you should
<a href="howtos/locally-published-components-in-ios.html">make a local build of Firefox for iOS</a>,
updating it to accomodate any changes in the component's public API.</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/application-services/edit/main/docs/howtos/converting-a-component-to-uniffi.md">Edit this file on GitHub.</a></footer><div style="break-before: page; page-break-before: always;"></div><h1 id="when-to-use-what-method-of-passing-data-between-rust-and-javaswift"><a class="header" href="#when-to-use-what-method-of-passing-data-between-rust-and-javaswift">When to use what method of passing data between Rust and Java/Swift</a></h1>
<p>There are a bunch of options here. For the purposes of our discussion,
there are two kinds of values you may want to pass over the FFI.</p>
<ol>
<li>Types with identity (includes stateful types, resource types, or anything that
isn't really serializable).</li>
<li>Plain ol' data.</li>
</ol>
<h2 id="types-with-identity"><a class="header" href="#types-with-identity">Types with identity</a></h2>
<p>Examples of this are things like database connections, the FirefoxAccounts
struct, etc. These types are complex, implemented in rust, and it's not
unreasonable for them to come to Java/Kotlin as a type representing a
resource (e.g. implementing <code>Closable</code>/<code>AutoClosable</code>).</p>
<p>You have two choices here:</p>
<ol>
<li>
<p>Use a <code>ConcurrentHandleMap</code> to store all instances of your object, and
pass the handle back and forth as a u64 from Rust / Long from Kotlin.</p>
<p>This is recommended for most cases, as it's the hardest to mess up.
Additionally, for types T such that <code>&amp;T: Sync + Send</code>, or that you
need to call <code>&amp;mut self</code> method, this is the safest choice.</p>
<p>Additionally, this will ensure panic-safety, as you'll poison your Mutex.</p>
<p>The <a href="https://docs.rs/ffi-support/*/ffi_support/handle_map/index.html"><code>ffi_support::handle_map</code> docs</a>
are good, and under <code>ConcurrentHandleMap</code> include an example of how to set
this up. You can also look at most of the FFI crates, as they do this (with
the exception of <code>rc_log</code>, which has unique requirements).</p>
</li>
<li>
<p>Using an opaque pointer. This is generally only recommended for rare cases
like the <code>PlacesInterruptHandle</code> (or the <code>LogAdapterState</code> from <code>rc_log</code>,
although it will probably eventually use a handle).</p>
<p>It's good if your synchronization or threading requirements are somewhat
complex and handled separately, such that the additional overhead of
the <code>ConcurrentHandleMap</code> is undesirable. You should probably talk to us
before adding another type that works this way, to make sure it's sound.</p>
<p>The <a href="https://docs.rs/ffi-support/*/ffi_support/macro.implement_into_ffi_by_pointer.html"><code>ffi_support</code> docs</a>
discuss how to do this, or take a look at how it's done for
<code>PlacesInterruptHandle</code>).</p>
</li>
</ol>
<h2 id="plain-old-data"><a class="header" href="#plain-old-data">Plain Old Data</a></h2>
<p>This includes both primitive values, strings, arrays, or arbitrarially nested
structures containing them.</p>
<h3 id="primitives"><a class="header" href="#primitives">Primitives</a></h3>
<p>Specifically numeric primitives. These we'll tackle first since they're the
easiest.</p>
<p>In general, you can just pass them as you wish. There are a couple of
exceptions/caveats. All of them are caused by JNA/Android issues (Swift has very
good support for calling over the FFI), but it's our lowest common denominator.</p>
<ol>
<li>
<p><code>bool</code>: Don't use it. JNA doesn't handle it well. Instead, use a numeric type
(like <code>u8</code>) and represent 0 for false and 1 for true for interchange over the
FFI, converting back to a Kotlin <code>Boolean</code> or swift <code>Bool</code> after (as to
not expose this somewhat annoying limitation in our public API).</p>
</li>
<li>
<p><code>usize</code>/<code>isize</code>: These cause the structure size to be different based on the
platform. JNA does handle this if you use <code>NativeSize</code>, but it's awkward,
incompatible with it's Direct Mapping optimization (which we don't use but
want to in the future), and has more overhead than just using <code>i64</code>/<code>i32</code> for
<code>Long</code>/<code>Int</code>. (You can also use <code>u64</code>/<code>u32</code> for <code>Long</code>/<code>Int</code>, if you're certain the
value is not negative)</p>
</li>
<li>
<p><code>char</code>: I really don't see a reason you need to pass a single codepoint over the
FFI, but if someone needs to do this, they instead should just pass it as a <code>u32</code>.</p>
<p>If you do this, you should probably be aware of the fact that Java chars are 16
bit, and Swift <code>Character</code>s are actually strings (they represent Extended
Grapheme Clusters, not codepoints).</p>
</li>
</ol>
<h3 id="strings"><a class="header" href="#strings">Strings</a></h3>
<p>These we pass as nul-terminated UTF-8 C-strings.</p>
<p>JNA automatically converts a <code>String</code> argument into a nul-terminated C-string,
but it will use the system default encoding unless specially configured.
<em>This may not be UTF-8</em>, in which case we use a custom TypeMapper to override
the default behaviour.</p>
<p>For return values, used <code>*mut c_char</code>, and for input, use
<a href="https://docs.rs/ffi-support/*/ffi_support/struct.FfiStr.html"><code>ffi_support::FfiStr</code></a></p>
<ol>
<li>
<p>If the string is returned from Rust to Kotlin/Swift, you need to expose a
string destructor from your ffi crate. See
<a href="https://docs.rs/ffi-support/*/ffi_support/macro.define_string_destructor.html"><code>ffi_support::define_string_destructor!</code></a>).</p>
<p>For converting to a <code>*mut c_char</code>, use either
<a href="https://docs.rs/ffi-support/*/ffi_support/fn.rust_string_to_c.html"><code>rust_string_to_c</code></a>
if you have a <code>String</code>, or
<a href="https://docs.rs/ffi-support/*/ffi_support/fn.opt_rust_string_to_c.html"><code>opt_rust_string_to_c</code></a>
for <code>Option&lt;String&gt;</code> (None becomes <code>std::ptr::null_mut()</code>).</p>
<p><strong>Important</strong>: In Kotlin, the type returned by a function that produces this
must be <code>Pointer</code>, and not <code>String</code>, and the parameter that the destructor takes
as input must also be <code>Pointer</code>.</p>
<p>Using <code>String</code> will <em>almost</em> work. JNA will convert the return value to
<code>String</code> automatically, leaking the value rust provides. Then, when passing
to the destructor, it will allocate a temporary buffer, pass it to Rust, which
we'll free, corrupting both heaps 💥. Oops!</p>
</li>
<li>
<p>If the string is passed into Rust from Kotlin/Swift, the rust code should
declare the parameter as a <a href="https://docs.rs/ffi-support/*/ffi_support/struct.FfiStr.html"><code>FfiStr&lt;'_&gt;</code></a>.
and things should then work more or less automatically. The <code>FfiStr</code> has methods
for extracting it's data as <code>&amp;str</code>, <code>Option&lt;&amp;str&gt;</code>, <code>String</code>, and <code>Option&lt;String&gt;</code>.</p>
</li>
</ol>
<p>It's also completely fine to use Protobufs or JSON for this case!</p>
<h3 id="aggregates"><a class="header" href="#aggregates">Aggregates</a></h3>
<p>This is any type that's more complex than a primitive or a string (arrays,
structures, and combinations there-in). There are two options we recommend for
these cases:</p>
<ol>
<li>
<p>Passing data using protobufs. See the
&quot;<a href="howtos/passing-protobuf-data-over-ffi.html">Using protobuf-encoded data over Rust FFI</a>&quot;
document for details on how to do this. We recommend this for all new use cases, unless
you have a specific reason that JSON is better (e.g. semi-opaque JSON encoded data is
desired on the other side).</p>
</li>
<li>
<p>Passing data as JSON. This is very easy, and useful for prototyping, however
much slower, requires a great deal of copying and redundant encode/decode
steps (in general, the data will be copied at least 4 times to make this
work, and almost certainly more in practice), and can be done relatively
easily by <code>derive(Serialize, Deserialize)</code>, and adding
<a href="https://docs.rs/ffi-support/*/ffi_support/macro.implement_into_ffi_by_json.html"><code>ffi_support::implement_into_ffi_by_json</code></a>
into the crate that defines the type.</p>
<p>Again, for new code, this is not a recommended approach for new code, unless
there's some reason it's preferrable for you.</p>
</li>
</ol>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/application-services/edit/main/docs/howtos/when-to-use-what-in-the-ffi.md">Edit this file on GitHub.</a></footer><div style="break-before: page; page-break-before: always;"></div><h1 id="rust--android-faqs"><a class="header" href="#rust--android-faqs">Rust + Android FAQs</a></h1>
<h3 id="how-do-i-expose-rust-code-to-kotlin"><a class="header" href="#how-do-i-expose-rust-code-to-kotlin">How do I expose Rust code to Kotlin?</a></h3>
<p>Use <a href="https://mozilla.github.io/uniffi-rs/">UniFFI</a>, which can produce Kotlin
bindings for your Rust code from an interface definition file.</p>
<p>If UniFFI doesn't currently meet your needs, please <a href="https://github.com/mozilla/uniffi-rs/issues">open an issue</a> to discuss how the tool can
be improved.</p>
<p>As a last resort, you can make hand-written bindings from Rust to Kotlin,
essentially manually performing the steps that UniFFI tries to automate
for you: flatten your Rust API into a bunch of <code>pub extern &quot;C&quot;</code> functions,
then use <a href="https://github.com/java-native-access/jna">JNA</a> to call them
from Kotlin. The details of how to do that are well beyond the scope of
this document.</p>
<h3 id="how-should-i-name-the-package"><a class="header" href="#how-should-i-name-the-package">How should I name the package?</a></h3>
<p>Published packages should be named <code>org.mozilla.appservices.$NAME</code> where <code>$NAME</code>
is the name of your component, such as <code>logins</code>.  The Java namespace in which
your package defines its classes etc should be <code>mozilla.appservices.$NAME.*</code>.</p>
<h3 id="how-do-i-publish-the-resulting-package"><a class="header" href="#how-do-i-publish-the-resulting-package">How do I publish the resulting package?</a></h3>
<p>Add it to <code>.buildconfig-android.yml</code> in the root of this repository.
This will cause it to be automatically included as part of our release
publishing pipeline.</p>
<h3 id="how-do-i-know-what-library-name-to-load-to-access-the-compiled-rust-code"><a class="header" href="#how-do-i-know-what-library-name-to-load-to-access-the-compiled-rust-code">How do I know what library name to load to access the compiled rust code?</a></h3>
<p>Assuming that you're building the Rust code as part of the application-services
build and release process, your <code>pub extern &quot;C&quot;</code> API should always be available
from a file named <code>libmegazord.so</code>.</p>
<h3 id="what-challenges-exist-when-calling-back-into-kotlin-from-rust"><a class="header" href="#what-challenges-exist-when-calling-back-into-kotlin-from-rust">What challenges exist when calling back into Kotlin from Rust?</a></h3>
<p>There are a number of them. The issue boils down to the fact that you need to be
completely certain that a JVM is associated with a given thread in order to call
java code on it. The difficulty is that the JVM can GC its threads and will not
let rust know about it.</p>
<p>JNA can work around this for us to some extent, at the cost of some complexity.
The approach it takes is essentially to spawn a thread for each callback
invocation. If you are certain you’re going to do a lot of callbacks and they
all originate on the same thread, you can have them all run on a single thread
by using the <a href="https://java-native-access.github.io/jna/4.2.1/com/sun/jna/CallbackThreadInitializer.html"><code>CallbackThreadInitializer</code></a>.</p>
<p>With the help of JNA's workarounds, calling back from Rust into Kotlin isn’t too bad
so long as you ensure that Kotlin cannot GC the callback while rust code holds onto it
(perhaps by stashing it in a global variable), and so long as you can either accept the overhead of extra threads being instantiated on each call or are willing to manage
the threads explicitly.</p>
<p>Note that the situation would be somewhat better if we used JNI directly (and
not JNA), but this would cause us to need to generate different Rust FFI code for
Android than for iOS.</p>
<p>Ultimately, in any case where there is an alternative to using a callback, you
should probably pursue that alternative.</p>
<p>For example if you're using callbacks to implement async I/O, it's likely better to
move to doing a blocking call, and have the calling code dispatch it on a background
thread. It’s very easy to run such things on a background thread in Kotlin, is in line
with the Android documentation on JNI usage, and in our experience is vastly simpler
and less painful than using callbacks.</p>
<p>(Of course, not every case is solvable like this).</p>
<h3 id="why-are-we-using-jna-rather-than-jni-and-what-tradeoffs-does-that-involve"><a class="header" href="#why-are-we-using-jna-rather-than-jni-and-what-tradeoffs-does-that-involve">Why are we using JNA rather than JNI, and what tradeoffs does that involve?</a></h3>
<p>We get a couple things from using JNA that we wouldn't with JNI.</p>
<ol>
<li>
<p>We are able to use the same Rust FFI code on all platforms. If we used JNI we'd
need to generate an Android-specific Rust FFI crate that used the JNI APIs, and
a separate Rust FFI crate for exposing to Swift.</p>
</li>
<li>
<p>JNA provides a mapping of threads to callbacks for us, making callbacks over
the FFI possible. That said, in practice this is still error prone, and easy
to misuse/cause memory safety bugs, but it's required for cases like logging,
among others, and so it is a nontrivial piece of complexity we'd have to
reimplement.</p>
</li>
</ol>
<p>However, it comes with the following downsides:</p>
<ol>
<li>JNA has bugs. In particular, its not safe to use bools with them, it thinks
they are 32 bits, when on most platforms (every platform Rust supports) they
are 8 bits. They've been unwilling to fix the issue due to it breaking
backwards compatibility (which is... somewhat fair, there is a lot of C89
code out there that uses <code>bool</code> as a typedef for a 32-bit <code>int</code>).</li>
<li>JNA makes it really easy to do the wrong thing and have it work but corrupt
memory. Several of the caveats around this are documented in the
<a href="https://docs.rs/ffi-support/*/ffi_support/"><code>ffi_support</code> docs</a>, but a
major one is when to use <code>Pointer</code> vs <code>String</code> (getting this wrong will
often work, but may corrupt memory).</li>
</ol>
<p>We aim to avoid triggering these bugs by auto-generating the JNA bindings
rather than writing them by hand.</p>
<h3 id="how-do-i-debug-rust-code-with-the-step-debugger-in-android-studio"><a class="header" href="#how-do-i-debug-rust-code-with-the-step-debugger-in-android-studio">How do I debug Rust code with the step-debugger in Android Studio</a></h3>
<ol>
<li>Uncomment the <code>packagingOptions { doNotStrip &quot;**/*.so&quot; }</code> line from the
build.gradle file of the component you want to debug.</li>
<li>In the rust code, either:
<ol>
<li>Cause something to crash where you want the breakpoint. Note: Panics
don't work here, unfortunately. (I have not found a convenient way to
set a breakpoint to rust code, so
<code>unsafe { std::ptr::write_volatile(0 as *const _, 1u8) }</code> usually is
what I do).</li>
<li>If you manage to get an LLDB prompt, you can set a breakpoint using
<code>breakpoint set --name foo</code>, or <code>breakpoint set --file foo.rs --line 123</code>.
I don't know how to bring up this prompt reliably, so I often do step 1 to
get it to appear, delete the crashing code, and then set the
breakpoint using the CLI. This is admittedly suboptimal.</li>
</ol>
</li>
<li>Click the Debug button in Android Studio, to display the &quot;Select Deployment
Target&quot; window.</li>
<li>Make sure the debugger selection is set to &quot;Both&quot;. This tends to unset
itself, so make sure.</li>
<li>Click &quot;Run&quot;, and debug away.</li>
</ol>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/application-services/edit/main/docs/android-faqs.md">Edit this file on GitHub.</a></footer><div style="break-before: page; page-break-before: always;"></div><h1 id="guide-to-consuming-rust-components-on-ios"><a class="header" href="#guide-to-consuming-rust-components-on-ios">Guide to Consuming Rust Components on iOS</a></h1>
<p>The application services libraries are published as a zip file containing a single composite (megazord) framework called <em>MozillaAppServices.framework</em>,
which contains the compiled code for all components.</p>
<p>The package is published as a release on github: https://github.com/mozilla/application-services/releases</p>
<h2 id="carthage"><a class="header" href="#carthage">Carthage</a></h2>
<ul>
<li>Add the dependency line to the Cartfile, for instance: <code>github &quot;mozilla/application-services&quot; ~&gt; &quot;v0.16.1&quot;</code> </li>
<li><code>carthage</code> will download MozillaAppServices.frameworks.zip, and add all the available frameworks to the 'Carthage/' dir.</li>
<li>Link against the provided MozillaAppServices.framework (in the <em>Link Binary with Libraries</em> step in your Xcode target).</li>
<li>Add additional dependencies, see <a href="howtos/consuming-rust-components-on-ios.html#additional-dependencies">below</a>.</li>
</ul>
<h3 id="adding-a-carthage-provided-framework-to-xcode"><a class="header" href="#adding-a-carthage-provided-framework-to-xcode">Adding a carthage provided framework to Xcode</a></h3>
<ul>
<li>In general, to do this, add <em>XXX.framework</em> from <em>Carthage/Build/iOS</em> to <em>Link binary with Libraries</em> for the Xcode target.</li>
<li>Update the list of additional dependencies below, so that consumers know to include the framework in their final build.</li>
</ul>
<h3 id="using-a-circle-ci-built-framework"><a class="header" href="#using-a-circle-ci-built-framework">Using a Circle-CI built framework</a></h3>
<p>Rather than using a tagged release version, one can grab the build from Circle-CI, like so:</p>
<p><code>binary &quot;https://circleci.com/api/v1.1/project/github/mozilla/application-services/2862/artifacts/0/dist/mozilla.app-services.json&quot; ~&gt; 0.0.1-snapshot</code></p>
<h2 id="additional-dependencies"><a class="header" href="#additional-dependencies">Additional dependencies</a></h2>
<p>The project has additional 3rd-party dependencies that a client must link against.</p>
<h3 id="nss"><a class="header" href="#nss">NSS</a></h3>
<ul>
<li>In your project, add all the .dylibs in the <code>../Carthage/Build/iOS/MozillaAppServices.framework</code> directory to both the &quot;Embedded Binaries&quot; and the &quot;Linked Frameworks and Libraries&quot; panels.</li>
</ul>
<h3 id="protobuf"><a class="header" href="#protobuf">Protobuf</a></h3>
<ul>
<li><em>SwiftProtoBuf.framework</em> should be automatically downloaded by carthage while pulling in the application-services dependency.</li>
<li><a href="howtos/consuming-rust-components-on-ios.html#adding-a-carthage-provided-framework-to-xcode">Add that framework to Xcode.</a></li>
</ul>
<h2 id="third-party-licenses"><a class="header" href="#third-party-licenses">Third-party licenses</a></h2>
<p>This project incorporates code from a number of third-party dependencies,
under a variety of open-source licenses. You should review the license info
in the file <code>DEPENDENCIES.md</code> and decide on an appropriate way to include
license and attribution notices into your product.</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/application-services/edit/main/docs/howtos/consuming-rust-components-on-ios.md">Edit this file on GitHub.</a></footer><div style="break-before: page; page-break-before: always;"></div><h2 id="application-services-logging"><a class="header" href="#application-services-logging">Application Services Logging</a></h2>
<p>When writing code in application-services, code implemented in Rust, Kotlin,
Java, or Swift might have to write debug logs. To do so, one should generally
log using the normal logging facilities for the language. Where the logs go
depends on the application which is embedding the components.</p>
<h3 id="accessing-logs-when-running-fenix"><a class="header" href="#accessing-logs-when-running-fenix">Accessing logs when running Fenix</a></h3>
<p>On android, logs currently go to logcat. (This may change in the future.)
Android Studio can be used to view the logcat logs; connect the device over USB
and view the Logcat tab at the bottom of Android Studio. Check to make sure you
have the right device selected at the top left of the Logcat pane, and the
correct process to the right of that. One trick to avoid having to select the
correct process (as there are main and content processes) is to choose &quot;No
Filters&quot; from the menu on the top right of the Logcat pane. Then, use the search
box to search for the log messages you are trying to find.</p>
<p>There are also many other utilities, command line and graphical, that can be
used to view logcat logs from a connected android device in a more flexible
manner.</p>
<h4 id="changing-the-loglevel-in-fenix"><a class="header" href="#changing-the-loglevel-in-fenix">Changing the loglevel in Fenix</a></h4>
<p>If you need more verbose logging, after the call to <code>RustLog.enable()</code> in
<code>FenixApplication</code>, you may call <code>RustLog.setMaxLevel(Log.Priority.DEBUG, true)</code>.</p>
<h3 id="accessing-logs-when-running-ios"><a class="header" href="#accessing-logs-when-running-ios">Accessing logs when running iOS</a></h3>
<p>[TODO]</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/application-services/edit/main/docs/logging.md">Edit this file on GitHub.</a></footer><div style="break-before: page; page-break-before: always;"></div><h1 id="architectural-decision-log"><a class="header" href="#architectural-decision-log">Architectural Decision Log</a></h1>
<p>This log lists the architectural decisions for MADR.</p>
<!-- adrlog -- Regenerate the content by using `./update-readme.sh`. Make sure to install `adr-log` via `npm install -g adr-log` -->
<ul>
<li><a href="adr/0000-use-markdown-architectural-decision-records.html">ADR-0000</a> - Use Markdown Architectural Decision Records</li>
<li><a href="adr/0001-update-logins-api.html">ADR-0001</a> - Update Logins API</li>
<li><a href="adr/0002-database-corruption.html">ADR-0002</a> - Handling Database Corruption</li>
<li><a href="adr/0003-swift-packaging.html">ADR-0003</a> - Distributing Swift Packages</li>
<li><a href="adr/0004-early-startup-experiments.html">ADR-0004</a> - Running experiments on first run early startup</li>
</ul>
<!-- adrlogstop -->
<p>For new ADRs, please use <a href="adr/template.html">template.md</a> as basis.
More information on MADR is available at <a href="https://adr.github.io/madr/">https://adr.github.io/madr/</a>.
General information about architectural decision records is available at <a href="https://adr.github.io/">https://adr.github.io/</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-markdown-architectural-decision-records"><a class="header" href="#use-markdown-architectural-decision-records">Use Markdown Architectural Decision Records</a></h1>
<h2 id="context-and-problem-statement"><a class="header" href="#context-and-problem-statement">Context and Problem Statement</a></h2>
<p>We want to record architectural decisions made in this project.
Which format and structure should these records follow?</p>
<h2 id="considered-options"><a class="header" href="#considered-options">Considered Options</a></h2>
<ul>
<li><a href="https://adr.github.io/madr/">MADR</a> 2.1.2 – The Markdown Architectural Decision Records</li>
<li><a href="http://thinkrelevance.com/blog/2011/11/15/documenting-architecture-decisions">Michael Nygard's template</a> – The first incarnation of the term &quot;ADR&quot;</li>
<li><a href="https://www.infoq.com/articles/sustainable-architectural-design-decisions">Sustainable Architectural Decisions</a> – The Y-Statements</li>
<li>Other templates listed at <a href="https://github.com/joelparkerhenderson/architecture_decision_record">https://github.com/joelparkerhenderson/architecture_decision_record</a></li>
<li>Formless – No conventions for file format and structure</li>
</ul>
<h2 id="decision-outcome"><a class="header" href="#decision-outcome">Decision Outcome</a></h2>
<p>Chosen option: &quot;MADR 2.1.2&quot;, because</p>
<ul>
<li>Implicit assumptions should be made explicit.
Design documentation is important to enable people understanding the decisions later on.
See also <a href="https://doi.org/10.1109/TSE.1986.6312940">A rational design process: How and why to fake it</a>.</li>
<li>The MADR format is lean and fits our development style.</li>
<li>The MADR structure is comprehensible and facilitates usage &amp; maintenance.</li>
<li>The MADR project is vivid.</li>
<li>Version 2.1.2 is the latest one available when starting to document ADRs.</li>
</ul>
<!-- markdownlint-disable-file MD013 -->
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/application-services/edit/main/docs/adr/0000-use-markdown-architectural-decision-records.md">Edit this file on GitHub.</a></footer><div style="break-before: page; page-break-before: always;"></div><h1 id="update-logins-api"><a class="header" href="#update-logins-api">Update Logins API</a></h1>
<ul>
<li>Status: accepted</li>
<li>Date: 2021-06-17</li>
</ul>
<p>Technical Story: <a href="https://github.com/mozilla/application-services/issues/4101">#4101</a></p>
<h2 id="context-and-problem-statement-1"><a class="header" href="#context-and-problem-statement-1">Context and Problem Statement</a></h2>
<p>We no longer want to depend on SQLCipher and want to use SQLite directly for build complexity and concerns over the long term future of the rust bindings. The encryption approach taken by SQLCipher means that in practice, the entire database is decrypted at startup, even if the logins functionality is not interacted with, defeating some of the benefits of using an encrypted database.</p>
<p>The per-field encryption in autofill, which we are planning to replicate in logins, separates the storage and encryption logic by limiting the storage layer to the management of encrypted data. Applying this approach in logins will break the existing validation and deduping code so we need a way to implement per-field encryption while supporting the validation and de-duping behavior.</p>
<h2 id="decision-drivers"><a class="header" href="#decision-drivers">Decision Drivers</a></h2>
<ul>
<li>Addressing previously identified deficiencies in the logins API while we are breaking the API for the encryption work</li>
<li>Continuing to support the existing logins validation and deduping logic</li>
<li>Avoiding the implementation of new security approaches that may require additional time and security resources</li>
<li>Establishing a standard encyrption approach across components</li>
</ul>
<h2 id="considered-options-1"><a class="header" href="#considered-options-1">Considered Options</a></h2>
<ul>
<li>Option 1 - Reduce the API functions that require the encryption key and pass the key to the remaining functions</li>
<li>Option 2 - Keep the general shape of the API that is in place now - the app can pass the encryption key at any time to &quot;unlock&quot; the API, and re-lock it at any time, but the API in its entirety is only available when unlocked</li>
</ul>
<h2 id="decision-outcome-1"><a class="header" href="#decision-outcome-1">Decision Outcome</a></h2>
<p>Chosen Option: &quot;Reduce the API functions that require the encryption key and pass the key to the remaining functions&quot; because it will not require a security review as similar to the approach we have established in the codebase.</p>
<h2 id="pros-and-cons-of-the-options"><a class="header" href="#pros-and-cons-of-the-options">Pros and Cons of the Options</a></h2>
<h3 id="option-1---reduce-the-api-functions-that-require-the-encryption-key-and-pass-the-key-to-the-remaining-functions"><a class="header" href="#option-1---reduce-the-api-functions-that-require-the-encryption-key-and-pass-the-key-to-the-remaining-functions">Option 1 - Reduce the API functions that require the encryption key and pass the key to the remaining functions</a></h3>
<ul>
<li>
<p>Description</p>
<p>Currently the below logins API functions would require the per-field encryption key:</p>
<ul>
<li>
<p><a href="https://github.com/mozilla/application-services/blob/1248a352cb2701b92395f2783bee8a88d18de455/components/logins/src/db.rs#L362">add</a></p>
</li>
<li>
<p><a href="https://github.com/mozilla/application-services/blob/1248a352cb2701b92395f2783bee8a88d18de455/components/logins/src/db.rs#L611">update</a></p>
</li>
<li>
<p><a href="https://github.com/mozilla/application-services/blob/1248a352cb2701b92395f2783bee8a88d18de455/components/logins/src/db.rs#L273">get_all</a></p>
</li>
<li>
<p><a href="https://github.com/mozilla/application-services/blob/1248a352cb2701b92395f2783bee8a88d18de455/components/logins/src/db.rs#L279">get_by_base_domain</a></p>
</li>
<li>
<p><a href="https://github.com/mozilla/application-services/blob/1248a352cb2701b92395f2783bee8a88d18de455/components/logins/src/db.rs#L330">get_by_id</a></p>
</li>
<li>
<p><a href="https://github.com/mozilla/application-services/blob/1248a352cb2701b92395f2783bee8a88d18de455/components/logins/src/db.rs#L663">check_valid_with_no_dupes</a></p>
</li>
<li>
<p><a href="https://github.com/mozilla/application-services/blob/1248a352cb2701b92395f2783bee8a88d18de455/components/logins/src/db.rs#L721">potential_dupes_ignoring_username</a></p>
</li>
<li>
<p><a href="https://github.com/mozilla/application-services/blob/1248a352cb2701b92395f2783bee8a88d18de455/components/logins/src/db.rs#L455">import_multiple</a></p>
<p><strong>Note:</strong></p>
<ul>
<li>Functions related to sync have been omitted as it is assumed they will have access to decrypted data.</li>
<li>The <code>get_all</code>, <code>get_by_base_domain</code>, and <code>get_by_id</code> functions will require the encryption key because they call the validate and fixup logic, not because we want to return logins with decrypted data.
Propsed changes:</li>
</ul>
</li>
<li>
<p>Combine the <code>add</code> and <code>update</code> functions into a new <code>add_or_update</code> function</p>
<ul>
<li>This will allow the removal of consumer code that distinguishes when a login record should be created or updated</li>
<li><strong>Note:</strong> This function needs the encryption key for the fixup and deduping logic <em>and</em> for continued support of the accurate population of the <code>time_password_changed</code> field</li>
</ul>
</li>
<li>
<p>Pass the per-field encryption key to the <code>import_multiple</code> function</p>
<ul>
<li>This function will be removed once the Fennec to Fenix migration period ends</li>
</ul>
</li>
<li>
<p>Remove both the <code>potential_dupes_ignoring_username</code> and <code>check_valid_with_no_dupes</code> from the API</p>
<ul>
<li>Neither function is called in Firefox iOS</li>
<li>Android Components uses both to provide validation and de-duping before logins are added or updated so we can eliminate the need to externalize these functions by replicating this logic in the new <code>add_or_update</code> function</li>
</ul>
</li>
<li>
<p>Create a <code>decrypt_and_fixup_login</code> function that both decrypts a login <em>and</em> performs the validate and fixup logic</p>
<ul>
<li>This will eliminate the need for the <code>get_all</code>, <code>get_by_base_domain</code>, and <code>get_by_id</code> API functions to perform the fixup logic
Making the above changes will reduce the API functions requiring the encryption key to the following:</li>
</ul>
</li>
<li>
<p><code>add_or_update</code></p>
</li>
<li>
<p><code>decrypt_and_fixup_login</code></p>
</li>
<li>
<p><code>import_multiple</code></p>
</li>
</ul>
</li>
<li>
<p>Pros</p>
<ul>
<li>Improves the logins API for consumers by combining add/update functionality (see <a href="https://github.com/mozilla/application-services/issues/3899">#3899</a> for details)</li>
<li>Removes redundant validation and de-duping logic in consumer code</li>
<li>Uses the same encryption model as autofill so there is consistency in our approaches</li>
</ul>
</li>
<li>
<p>Cons</p>
<ul>
<li>Requires consumer code to both encrypt login fields <em>and</em> pass the encryption key when calling either <code>add_or_update</code> and <code>import_multiple</code></li>
</ul>
</li>
</ul>
<h3 id="option-2---implement-a-different-key-management-approach"><a class="header" href="#option-2---implement-a-different-key-management-approach">Option 2 - Implement a different key management approach</a></h3>
<ul>
<li>
<p>Description</p>
<p>Unlike the first option, the publicly exposed login API would only handle decrypted login records and all encryption is internal (which works because we always have the key). Any attempt to use the API will fail as the login records are not encrypted or decrypted if the key is not available.</p>
<p>Proposed changes:</p>
<ul>
<li>Combine the <code>add</code> and <code>update</code> functions into <code>add_or_update</code></li>
<li>Remove both the <code>potential_dupes_ignoring_username</code> and <code>check_valid_with_no_dupes</code> from the API</li>
</ul>
</li>
<li>
<p>Pros</p>
<ul>
<li>Prevents the consumer from having to encrypt or decrypt login records</li>
<li>Maintains our current fixup and validation approach</li>
<li>Improves the logins API for consumers by combining add/update functionality</li>
<li>Removes redundant validation and de-duping logic in consumer code</li>
</ul>
</li>
<li>
<p>Cons</p>
<ul>
<li>Makes us responsible for securing the encryption key and will most likely require a security review</li>
</ul>
</li>
</ul>
<h2 id="links"><a class="header" href="#links">Links</a></h2>
<ul>
<li><a href="https://docs.google.com/drawings/d/1GZExe9lNpNDCoywpmg4RxHHNoqyaQ2CapbUyoM3K-KQ/edit?usp=sharing">Logins Validate and Fixup Call Tree</a></li>
</ul>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/application-services/edit/main/docs/adr/0001-update-logins-api.md">Edit this file on GitHub.</a></footer><div style="break-before: page; page-break-before: always;"></div><h1 id="handling-database-corruption"><a class="header" href="#handling-database-corruption">Handling Database Corruption</a></h1>
<ul>
<li>Status: accepted</li>
<li>Date: 2021-06-08</li>
</ul>
<h2 id="context-and-problem-statement-2"><a class="header" href="#context-and-problem-statement-2">Context and Problem Statement</a></h2>
<p>Some of our users have corrupt SQLite databases and this makes the related
component unusable.  The best way to deal with corrupt databases is to simply
delete the database and start fresh (#2628).  However, we only want to do this
for persistent errors, not transient errors like programming logic errors, disk
full, etc.  This ADR deals with 2 related questions:</p>
<ul>
<li>A) When and how do we identify corrupted databases?</li>
<li>B) What do we do when we identify corrupted databases?</li>
</ul>
<h2 id="decision-drivers-1"><a class="header" href="#decision-drivers-1">Decision Drivers</a></h2>
<ul>
<li>Deleting valid user data should be avoided at almost any cost</li>
<li>Keeping a corrupted database around is almost as bad.  It currently prevents
the component from working at all.</li>
<li>We don't currently have a good way to distinguish between persistent and
transient errors, but this can be improved by reviewing telemetry and sentry
data.</li>
</ul>
<h2 id="considered-options-2"><a class="header" href="#considered-options-2">Considered Options</a></h2>
<ul>
<li>A) When and how do we identify corrupted databases?
<ul>
<li>1: Assume all errors when opening a database are from corrupt databases</li>
<li>2: Check for errors when opening a database and compare against known corruption error types</li>
<li>3: Check for errors for all database operations and compare against known corruption error types</li>
</ul>
</li>
<li>B) What do we do when we identify corrupted databases?
<ul>
<li>1: Delete the database file and recreate the database</li>
<li>2: Move the database file and recreate the database</li>
<li>3: Have the component fail</li>
</ul>
</li>
</ul>
<h2 id="decision-outcome-2"><a class="header" href="#decision-outcome-2">Decision Outcome</a></h2>
<ul>
<li>A2: Check for errors when opening a database and compare against known corruption error types</li>
<li>B1: Delete the database file and recreate the database</li>
</ul>
<p>Decision B follows from the choice of A.  Since we're being conservative in
identifying errors, we can delete the database file with relative confidence.</p>
<p>&quot;Check for errors for all database operations and compare against known
corruption error types&quot; also seems like a reasonable solution that we may
pursue in the future, but we decided to wait for now.  Checking for errors
during opening time is the simpler solution to implement and should fix the
issue in many cases.  The plan is to implement that first, then monitor
sentry/telemetry to decide what to do next.</p>
<h1 id="pros-and-cons-of-the-options-1"><a class="header" href="#pros-and-cons-of-the-options-1">Pros and Cons of the Options</a></h1>
<h3 id="a1-assume-all-errors-when-opening-a-database-are-from-corrupt-databases"><a class="header" href="#a1-assume-all-errors-when-opening-a-database-are-from-corrupt-databases">A1: Assume all errors when opening a database are from corrupt databases</a></h3>
<ul>
<li>Good, because the sentry data indicates that many errors happen during opening time</li>
<li>Good, because migrations are especially likely to trigger corruption errors</li>
<li>Good, because it's a natural time to delete the database -- the consumer code
hasn't run any queries yet and doesn't have any open connections.</li>
<li>Bad, because it will delete valid user data in several situations that are
relatively common: migration logic errors, OOM errors, Disk full.</li>
</ul>
<h3 id="a2-check-for-errors-when-opening-a-database-and-compare-against-known-corruption-error-types-decided"><a class="header" href="#a2-check-for-errors-when-opening-a-database-and-compare-against-known-corruption-error-types-decided">A2: Check for errors when opening a database and compare against known corruption error types (Decided)</a></h3>
<ul>
<li>Good, because should eliminate the possibility of deleting valid user data.</li>
<li>Good, because the sentry data indicates that many errors happen during opening time</li>
<li>Good, because it's a natural time to delete the database -- the consumer code
hasn't run any queries yet and doesn't have any open connections.</li>
<li>Bad, because we don't currently have a good list corruption errors</li>
</ul>
<h3 id="a3-check-for-errors-for-all-database-operations-and-compare-against-known-corruption-error-types"><a class="header" href="#a3-check-for-errors-for-all-database-operations-and-compare-against-known-corruption-error-types">A3: Check for errors for all database operations and compare against known corruption error types</a></h3>
<ul>
<li>Good, because the sentry data indicates that many errors happen outside of opening time</li>
<li>Good, because should eliminate the possibility of deleting valid user data.</li>
<li>Bad, because the consumer code probably doesn't expect the database to be
deleted and recreated in the middle of a query.  However, this is just an
extreme case of normal database behavior -- for example any given row can be
deleted during a sync.</li>
<li>Bad, because we don't currently have a good list corruption errors</li>
</ul>
<h3 id="b1-delete-the-database-file-and-recreate-the-database-decided"><a class="header" href="#b1-delete-the-database-file-and-recreate-the-database-decided">B1: Delete the database file and recreate the database (Decided)</a></h3>
<ul>
<li>Good, because it would allow users with corrupted databases to use the
affected components again</li>
<li>Bad, because any misidentification will lead to data loss.</li>
</ul>
<h3 id="b2-move-the-database-file-and-recreate-the-database"><a class="header" href="#b2-move-the-database-file-and-recreate-the-database">B2: Move the database file and recreate the database</a></h3>
<p>This option would be similar to 1, but instead of deleting the file we would
move it to a backup location.  When we started up, we could look for backup
files and try to import lost data.</p>
<ul>
<li>Good, because if we misidentify corrupt databases, then we have the
possibility of recovering the data</li>
<li>Good, because it allows a way for users to delete their data (in theory).
If the consumer code executed a <code>wipe()</code> on the database, we could also
delete any backup data.</li>
<li>Bad, because it's very difficult to write a recovery function that merged
deleted data with any new data.  This function would be fairly hard to test
and it would be easy to introduce a new logic error.</li>
<li>Bad, because it adds significant complexity to the database opening code</li>
<li>Bad, because the user experience would be strange.  A user would open the
app, discover that their data was gone, then sometime later discover that the
data is back again.</li>
</ul>
<h3 id="b3-return-a-failure-code"><a class="header" href="#b3-return-a-failure-code">B3: Return a failure code</a></h3>
<ul>
<li>Good, because this option leaves no chance of user data being deleted</li>
<li>Good, because it's the simplest to implement</li>
<li>Bad, because the component will not be usable if the database is corrupt</li>
<li>Bad, because the user's data is potentially exposed in the corrupted database
file and we don't provide any way for them to delete it.</li>
</ul>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/application-services/edit/main/docs/adr/0002-database-corruption.md">Edit this file on GitHub.</a></footer><div style="break-before: page; page-break-before: always;"></div><h1 id="distributing-swift-packages"><a class="header" href="#distributing-swift-packages">Distributing Swift Packages</a></h1>
<ul>
<li>Status: accepted</li>
<li>Deciders: rfkelly</li>
<li>Date: 2021-07-22</li>
</ul>
<h2 id="context-and-problem-statement-3"><a class="header" href="#context-and-problem-statement-3">Context and Problem Statement</a></h2>
<p>Our iOS consumers currently obtain application-services as a pre-compiled <code>.framework</code> bundle
distributed via <a href="https://github.com/Carthage/Carthage">Carthage</a>. The current setup is not
compatible with building on new M1 Apple Silicon machines and has a number of other problems.
As part of a broader effort to modernize the build process of iOS applications at Mozilla,
we have been asked to re-evaluate how application-services components are dsitributed for iOS.</p>
<p>See <a href="adr/0003-swift-packaging.html#problems-with-the-current-setup">Problems with the current setup</a> for more details.</p>
<h2 id="decision-drivers-2"><a class="header" href="#decision-drivers-2">Decision Drivers</a></h2>
<ul>
<li>Ease-of-use for iOS consumers.</li>
<li>Compatibility with M1 Apple Silicon machines.</li>
<li>Consistency with other iOS components being developed at Mozilla.</li>
<li>Ability for the Nimbus Swift bindings to easily depend on Glean.</li>
<li>Ease of maintainability for application-services developers.</li>
</ul>
<h2 id="considered-options-3"><a class="header" href="#considered-options-3">Considered Options</a></h2>
<ul>
<li><strong>(A) Do Nothing</strong>
<ul>
<li>Keep our current build and distribution setup as-is.</li>
</ul>
</li>
<li><strong>(B) Use Carthage to build XCFramework bundles</strong>
<ul>
<li>Make a minimal change to our Carthage setup so that it builds
the newer XCFramework format, which can support M1 Apple Silicon.</li>
</ul>
</li>
<li><strong>(C) Distribute a single pre-compiled Swift Package</strong>
<ul>
<li>Convert the all-in-one <code>MozillaAppServices</code> Carthage build to a similar
all-in-one Swift Package, distributed as a binary artifact.</li>
</ul>
</li>
<li><strong>(D) Distribute multiple source-based Swift Package targets, with pre-compiled Rust code</strong>
<ul>
<li>Split the all-in-one <code>MozillaAppServices</code> Carthage build into a separate
Swift Package target for each component, with a shared dependency on pre-compiled
Rust code as a binary artiact.</li>
</ul>
</li>
</ul>
<h2 id="decision-outcome-3"><a class="header" href="#decision-outcome-3">Decision Outcome</a></h2>
<p>Chosen option: <strong>(D) Distribute multiple source-based Swift Packages, with pre-compiled Rust code</strong>.</p>
<p>This option will provide the best long-term consumer experience for iOS developers, and
has the potential to simplify maintenance for application-services developers after an
initial investment of effort.</p>
<h3 id="positive-consequences"><a class="header" href="#positive-consequences">Positive Consequences</a></h3>
<ul>
<li>Swift packages are very convenient to consume in newer versions of Xcode.</li>
<li>Different iOS apps can choose to import a different subset of the available components,
potentiallying helping keep application size down.</li>
<li>Avoids issues with mis-matched Swift version between application-services build
and consumers, since Swift files are distributed in source form.</li>
<li>Encourages better conceptual separation between Swift code for different components;
e.g. it will make it possible for two Swift components to define an item of the same
name without conflicts.</li>
<li>Reduces the need to use Xcode as part of application-services build process, in favour
of command-line tools.</li>
</ul>
<h3 id="negative-consequences"><a class="header" href="#negative-consequences">Negative Consequences</a></h3>
<ul>
<li>More up-front work to move to this new setup.</li>
<li>We may be less likely to notice if our build setup breaks when used from within Xcode,
because we're not exercising that code path ourselves.</li>
<li>May be harder to concurrently publish a Carthage framework for current consumers who aren't
able to move to Swift packages.</li>
<li>There is likely to be some amount of API breakage for existing consumers, if only in having
to replace a single <code>import MozillaAppServices</code> with independent imports of each component.</li>
</ul>
<h3 id="implementation-sketch"><a class="header" href="#implementation-sketch">Implementation Sketch</a></h3>
<p>We will maintain the existing Carthage build infrastructure in the application-services repo and continue publishing a pre-built Carthage framework,
to support firefox-ios until they migrate to Swift Packages.</p>
<p>We will add an additional iOS build task in the application-services repo, that builds <em>just the Rust code</em> as a <code>.xcframework</code> bundle.
An initial prototype shows that this can be achieved using a relatively straightforward shell script, rather than requiring a second Xcode project.
It will be published as a <code>.zip</code> artifact on each release in the same way as the current Carthage framework.
The Rust code will be built as a static library, so that the linking process of the consuming application can pull in
just the subset of the Rust code that is needed for the components it consumes.</p>
<p>We will initially include only Nimbus and its dependencies in the <code>.xcframework</code> bundle,
but will eventually expand it to include all Rust components (including Glean, which will continue
to be included in the <code>application-services</code> repo as a git submodule)</p>
<p>We will create a new repository <code>rust-components-swift</code> to serve as the root of the new Swift Package distribution.
It will import the <code>application-services</code> repository as a git submodule. This will let us iterate quickly on the
Swift packaging setup without impacting existing consumers.</p>
<p>We will initially include only Nimbus and its dependencies in this new repository, and the Nimbus swift code
it will depend on Glean via the external <code>glean-swift</code> package. In the future we will publish all application-services
components that have a Swift interface through this repository, as well as Glean and any future Rust components.
(That's why the repository is being given a deliberately generic name).</p>
<p>The <code>rust-components-swift</code> repo will contain a <code>Package.swift</code> file that defines:</p>
<ul>
<li>A single binary target that references the pre-built <code>.xcframework</code> bundle of Rust code.</li>
<li>One Swift target for each component, that references the Swift code from the git submodule
and depends on the pre-built Rust code.</li>
</ul>
<p>We will add automation to the <code>rust-components-swift</code> repo so that it automatically tracks
releases made in the <code>application-services</code> repo and creates a corresponding git tag for
the Swift package.</p>
<p>At some future date when all consumers have migrated to using Swift packages, we will remove
the Carthage build setup from the application-services repo.</p>
<p>At some future date, we will consider whether to move the <code>Package.swift</code> definition in to the <code>application-services</code> repo,
or whether it's better to keep it separate. (Attempting to move it into the <code>application-services</code> will involve non-trivial
changes to the release process, because the checksum of the released <code>.xcframework</code> bundle needs to be included in
the release taged version of the <code>Package.swift</code> file.)</p>
<h1 id="pros-and-cons-of-the-options-2"><a class="header" href="#pros-and-cons-of-the-options-2">Pros and Cons of the Options</a></h1>
<h3 id="a-do-nothing"><a class="header" href="#a-do-nothing"><strong>(A) Do Nothing</strong></a></h3>
<p>In this option, we would make no changes to our iOS build and publishing process.</p>
<ul>
<li>Good, because it's the least amount of work.</li>
<li>Neutral, because it doesn't change the maintainability of the system for appservices
developers.</li>
<li>Neutral, because it doesn't change the amount of separation between Swift code
for our various components.</li>
<li>Neutral, because it doesn't address the Swift version incompatibility issues around
binary artifacts.</li>
<li>Bad, because it will frustrate consumers who want to develop on M1 Apple Silicon.</li>
<li>Bad, because it may prevent consumers from migrating to a more modern build setup.</li>
<li>Bad, because it would prevent consumers from consuming Glean as a Swift package;
we would require them to use the Glean that is bundled in our build.</li>
</ul>
<p>This option isn't really tractable for us, but it's included for completeness.</p>
<h3 id="b-use-carthage-to-build-xcframework-bundles"><a class="header" href="#b-use-carthage-to-build-xcframework-bundles"><strong>(B) Use Carthage to build XCFramework bundles</strong></a></h3>
<p>In this option, we would try to change our iOS build and publising process as little
as possible, but use Carthage's recent support for <a href="https://github.com/Carthage/carthage#building-platform-independent-xcframeworks-Xcode-12-and-above">building platform-independent
XCFrameworks</a> in order
to support consumers running on M1 Apple Silicon.</p>
<ul>
<li>Good, because the size of the change is small.</li>
<li>Good, because we can support development on newer Apple machines.</li>
<li>Neutral, because it doesn't change the maintainability of the system for appservices
developers.</li>
<li>Neutral, because it doesn't change the amount of separation between Swift code
for our various components.</li>
<li>Neutral, because it doesn't address the Swift version incompatibility issues around
binary artifacts.</li>
<li>Bad, because our iOS consumers have expressed a preference for moving away from Carthage.</li>
<li>Bad, because other iOS projects at Mozilla are moving to Swift Packages, making
us inconsistent with perceived best practice.</li>
<li>Bad, because it would prevent consumers from consuming Glean as a Swift package;
we would require them to use the Glean that is bundled in our build.</li>
<li>Bad, because consumers don't get to choose which components they want to use (without
us building a whole new &quot;megazord&quot; with just the components they want).</li>
</ul>
<p>Overall, current circumstances feel like a good opportunity to invest a little more
time in order to set ourselves up for better long-term maintainability
and happier consumers. The main benefit of this option (it's quicker!) is less attractive
under those circumstances.</p>
<h3 id="c-distribute-a-single-pre-compiled-swift-package"><a class="header" href="#c-distribute-a-single-pre-compiled-swift-package"><strong>(C) Distribute a single pre-compiled Swift Package</strong></a></h3>
<p>In this option, we would compile the Rust code and Swift code for all our components into
a single <code>.xcframework</code> bundle, and then distribute that as a
<a href="https://developer.apple.com/documentation/swift_packages/distributing_binary_frameworks_as_swift_packages">binary artifact</a> via Swift Package. This is similar to the approach
currently taken by Glean (ref <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1711447">Bug 1711447</a>)
except that they only have a single component.</p>
<ul>
<li>Good, because Swift Packages are the preferred distribution format for new iOS consumers.</li>
<li>Good, because we can support development on newer Apple machines.</li>
<li>Good, because it aligns with what other iOS component developers are doing at Mozilla.</li>
<li>Neutral, because it doesn't change the maintainability of the system for appservices
developers.
<ul>
<li>(We'd need to keep the current Xcode project broadly intact).</li>
</ul>
</li>
<li>Neutral, because it doesn't change the amount of separation between Swift code
for our various components.</li>
<li>Neutral, because it doesn't address the Swift version incompatibility issues around
binary artifacts.</li>
<li>Neutral, because it would prevent consumers from consuming Glean as a separate Swift package;
they'd have to get it as part of <em>our</em> all-in-one Swift package.</li>
<li>Bad, because it's a larger change and we have to learn about a new package manager.</li>
<li>Bad, because consumers don't get to choose which components they want to use (without
building a whole new &quot;megazord&quot; with just the components they want).</li>
</ul>
<p>Overall, this option would be a marked improvement on the status quo, but leaves out some potential
improvements. For not that much more work, we can make some of the &quot;Neutral&quot; and &quot;Bad&quot; points
here into &quot;Good&quot; points.</p>
<h3 id="d-distribute-multiple-source-based-swift-packages-with-pre-compiled-rust-code"><a class="header" href="#d-distribute-multiple-source-based-swift-packages-with-pre-compiled-rust-code"><strong>(D) Distribute multiple source-based Swift Packages, with pre-compiled Rust code</strong></a></h3>
<p>In this option, we would compile <em>just the Rust code</em> for all our components into a single
<code>.xcframework</code> bundle and distribute that as a <a href="https://developer.apple.com/documentation/swift_packages/distributing_binary_frameworks_as_swift_packages">binary artifact</a> via Swift Package.
We would then declare a separate Swift <em>source</em> target for the Swift wrapper of each component,
each depending on the compiled Rust code but appearing as a separate item in the Swift package
definition.</p>
<ul>
<li>Good, because Swift Packages are the preferred distribution format for new iOS consumers.</li>
<li>Good, because we can support development on newer Apple machines.</li>
<li>Good, because it aligns with what other iOS component developers are doing at Mozilla.</li>
<li>Good, because it can potentially simplify the maintenance of the system for appservices
developers, by removing Xcode in favour of some command-line scripts.</li>
<li>Good, because it introduces strict separation between the Swift code for each component,
instead of compiling them all together in a single shared namespace.</li>
<li>Good, because the Nimbus Swift package could cleanly depend on the Glean Swift package.</li>
<li>Good, because consumers can choose which components they want to include.</li>
<li>Good, because it avoids issues with Swift version incompatibility in binary artifacts.</li>
<li>Bad, because it's a larger change and we have to learn about a new package manager.</li>
</ul>
<p>The only downside to this option appears to be the amount of work involved, but an initial
prototype has given us some confidence that the change is tractable and that it may lead
to a system that is easier to maintain over time. It is thus our preferred option.</p>
<h1 id="appendix"><a class="header" href="#appendix">Appendix</a></h1>
<h2 id="further-reading"><a class="header" href="#further-reading">Further Reading</a></h2>
<ul>
<li><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1711447">Bug 1711447</a> has good historical context on the work to move Glean to using a Swift Package.</li>
<li>Some material on swift packages:
<ul>
<li><a href="https://www.swiftbysundell.com/articles/managing-dependencies-using-the-swift-package-manager/">Managing dependencies using the Swift Package Manager</a> was a useful overview.</li>
<li><a href="https://www.timc.dev/posts/understanding-swift-packages/">Understanding Swift Packages and Dependency Declarations</a> gives a bit of a deeper dive into having multiple targets
with different names in a single package.</li>
</ul>
</li>
<li>Outputs of initial prototype:
<ul>
<li>A prototype of Option (C): <a href="https://github.com/mozilla/application-services/pull/4216">Nimbus + Glean as a pre-built XCFramework Swift Package</a></li>
<li>A prototype of Option (D): <a href="https://github.com/mozilla/application-services/pull/4225">Rust code as XCFRamework</a> plus a <a href="https://github.com/rfk/rust-components-swift">Multi-product Swift Package</a> that depends on it.
<ul>
<li>A <a href="https://drive.google.com/file/d/12xsOMoFkxHZAEZ8tL5gBaiTYTYoQN1OO/view">video demo</a> of the resulting consumer experience.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="problems-with-the-current-setup"><a class="header" href="#problems-with-the-current-setup">Problems with the current setup</a></h2>
<p>It doesn't build for M1 Apple Silicon machines, because it's not possible to support
both arm64 device builds and arm64 simulator builds in a single binary <code>.framework</code>.</p>
<p>Carthage is dispreferred by our current iOS consumers.</p>
<p>We don't have much experience with the setup on the current Application Services team,
and many of its details are under-documented. Changing the build setup requires Xcode
and some baseline knowledge of how to use it.</p>
<p>All components are built as a single Swift module, meaning they can see each other's
internal symbols and may accidentally conflict when naming things. For example we can't
currently have two components that define a structure of the same name.</p>
<p>Consumers can only use the pre-built binary artifacts if they are using the same
version of Xcode as was used during the application-services build. We are not able
to use Swift's <code>BUILD_LIBRARY_FOR_DISTRIBUTION</code> flag to overcome this, because some
of our dependencies do not support this flag (specifically, the Swift protobuf lib).</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/application-services/edit/main/docs/adr/0003-swift-packaging.md">Edit this file on GitHub.</a></footer><div style="break-before: page; page-break-before: always;"></div><h1 id="running-experiments-on-first-run-early-startup"><a class="header" href="#running-experiments-on-first-run-early-startup">Running experiments on first run early startup</a></h1>
<ul>
<li>Status: rejected</li>
<li>Deciders: teshaq, travis, k88hudson, jhugman, jaredlockhart</li>
<li>Date: 2021-08-16</li>
</ul>
<p>Technical Story: https://mozilla-hub.atlassian.net/browse/SDK-323</p>
<h2 id="context-and-problem-statement-4"><a class="header" href="#context-and-problem-statement-4">Context and Problem Statement</a></h2>
<p>As an experimenter, I would like to run experiments early on a user's first run of the application. However, the experiment data is only available on the second run. We would like to have that experiment data available before the user's first run.
For more information: https://docs.google.com/document/d/1Qw36_7G6XyHvJZdM-Hxh4nqYZyCsYajG0L5mO33Yd5M/edit</p>
<h2 id="decision-drivers-3"><a class="header" href="#decision-drivers-3">Decision Drivers</a></h2>
<ul>
<li>Availability of experiments early on the first run</li>
<li>No impact on experimentation data analysis</li>
<li>Flexibility in creating experiments</li>
<li>Ability to quickly disable experiments</li>
<li>Simplicity of releases</li>
<li>Mobile's expectations of Nimbus (The SDK should be idempotent)</li>
</ul>
<h2 id="considered-options-4"><a class="header" href="#considered-options-4">Considered Options</a></h2>
<ul>
<li><strong>(A) Do Nothing</strong>
<ul>
<li>Keep everything the way it is, preventing us from experimenting on users early on their first run</li>
</ul>
</li>
<li><strong>(B) Bundle Experiment data with app on release</strong>
<ul>
<li>On release, have an <code>initial_experiments.json</code> that defines the experiments that will be applied early on the first run</li>
<li>Later on the first run, the client would retrieve the actual experiment data from remote-settings and overwrite the bundled data</li>
</ul>
</li>
<li><strong>(C) Retrieve Experiment data on first run, and deal with delay</strong>
<ul>
<li>We can retrieve the experiment data on the first run, experiment data however will not be available until after a short delay (network I/O + some disk I/O)</li>
</ul>
</li>
</ul>
<h2 id="decision-outcome-4"><a class="header" href="#decision-outcome-4">Decision Outcome</a></h2>
<p>None of the options were feasible, so for now we are sticking with option <strong>(A) Do Nothing</strong> until there are experiments planned that are expected to run on early startup on the first run, then we will revaluate our options.</p>
<p>The <strong>(B) Bundle Experiment data with app on release</strong> option was rejected mainly due to difficulty in disabling experiments and pausing enrollments. This can create a negative user experience as it prevents us from disabling any problematic experiments. Additionally, it ties experiment creation with application release cycles.</p>
<p>The <strong>(C) Retrieve Experiment data on first run, and deal with delay</strong> option was rejected due to the fact it changes the Nimbus SDK will no longer be idempotent,and the possibility of introducing undesirable UI.</p>
<h2 id="pros-and-cons-of-the-options-3"><a class="header" href="#pros-and-cons-of-the-options-3">Pros and Cons of the Options</a></h2>
<h3 id="do-nothing"><a class="header" href="#do-nothing">Do nothing</a></h3>
<ul>
<li>Good, because it keeps the flexibility in experiment creation</li>
<li>Good, because disabling experiments can still done remotely for all experiments</li>
<li>Good, because it keeps the Nimbus SDK idempotent.</li>
<li>Bad, because it doesn't address the main problem of exposing experiments to user on their first run</li>
</ul>
<h3 id="bundle-experiment-data-with-app-on-release"><a class="header" href="#bundle-experiment-data-with-app-on-release">Bundle Experiment data with app on release</a></h3>
<ul>
<li>Good, because it allows us to run experiments early on a user's first run</li>
<li>Good, because it prevents us from having to wait for experiments, especially if a user has a slow network connection</li>
<li>Bad, because it ties experiment creation with release cycles</li>
<li>Bad, because it prevents us from disabling problematic first-run experiments without a dot release</li>
<li>Bad, because it prevents us from pausing enrollment on first-run experiments without a dot release</li>
<li>Bad, because it requires investment from the console team, and can modify existing flows.</li>
</ul>
<h3 id="retrieve-experiment-data-on-first-run-and-deal-with-delay"><a class="header" href="#retrieve-experiment-data-on-first-run-and-deal-with-delay">Retrieve Experiment data on first run, and deal with delay</a></h3>
<ul>
<li>Good, because it enables us to retrieve experiments for users on their first run</li>
<li>Good, because it keeps the flexibility in experiment creation</li>
<li>Good, because disabling experiments can still done remotely for all experiments</li>
<li>Bad, because experiments may not be ready early on the user's experience</li>
<li>Bad, because it forces the customer application to deal with either the delay, or changing the configuration shortly after startup. e.g. a loading spinner or a pre-onboarding screen not under experimental control; delaying initialization of onboarding screens until after experiments have been loaded.</li>
<li>Bad, because it changes the programming model from Nimbus being an idempotent configuration store to configuration changing non-deterministically.</li>
<li>Bad, because the experimentation platform could force the app to add unchangeable user interface for the entire population. This itself may have an effect on key metrics.</li>
</ul>
<h2 id="links-1"><a class="header" href="#links-1">Links</a></h2>
<ul>
<li><a href="https://docs.google.com/document/d/1Qw36_7G6XyHvJZdM-Hxh4nqYZyCsYajG0L5mO33Yd5M/edit#heading=h.b1n8hquqkety">RFC for bundling into iOS and Fenix</a></li>
<li>Document presented to product managers about <strong>(C) Retrieve Experiment data on first run, and deal with delay</strong>: https://docs.google.com/document/d/1X1hC3t5zC7-Rp0OPIoiUr_ueLOAI0ez_jqslaNzOHjY/edit</li>
<li>Demo presenting option <strong>(C) Retrieve Experiment data on first run, and deal with delay</strong>: https://drive.google.com/file/d/19HwnlwrabmSNsB7tjW2l4kZD3PWABi4u/view?usp=sharing</li>
</ul>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/application-services/edit/main/docs/adr/0004-early-startup-experiments.md">Edit this file on GitHub.</a></footer><div style="break-before: page; page-break-before: always;"></div><h1 id="design-documents"><a class="header" href="#design-documents">Design Documents</a></h1>
<ul>
<li><a href="design/megazords.html">Megazords</a> - Megazords and how we ship code</li>
<li><a href="design/sync-manager.html">Sync Manager</a> - Our Sync Manager and how Sync works in using it</li>
<li><a href="design/swift-package-manager.html">Shipping Rust Components as Swift Packages</a> - High level design of how use the Swift Package Manager to distribute our Rust components to iOS</li>
<li><a href="design/sync-overview.html">Sync overview</a> - High level overview of how Firefox sync works</li>
<li><a href="design/components-strategy.html">Rust Component's Strategy</a> - High level description of our Rust components strategy</li>
<li><a href="design/metrics.html">Metrics - (Glean Telemetry)</a></li>
<li><a href="design/rust-versions.html">Rust Version Policy</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="megazording"><a class="header" href="#megazording">Megazording</a></h1>
<p>Each Rust component published by Application Services is conceptually a stand-alone library, but for
distribution we compile all the rust code for all components together into a single <code>.so</code> file. This
has a number of advantages:</p>
<ul>
<li>Easy and direct interoperability between different components at the Rust level</li>
<li>Cross-component optimization of generated code</li>
<li>Reduced code size thanks to distributing a single copy of the rust stdlib, low-level dependencies, etc.</li>
</ul>
<p>This process is affectionately known as &quot;megazording&quot; and the resulting artifact as a <em><strong>megazord library</strong></em>.</p>
<p>On Android, the situation is quite complex due to the way packages and dependencies are managed.
We need to distribute each component as a separate Android ARchive (AAR) that can be managed as a dependency
via gradle, we need to provide a way for the application to avoid shipping rust code for components that it
isn't using, and we need to do it in a way that maintanins the advantages listed above.</p>
<p>This document describes our current approach to meeting all those requirements on Android. Other platforms
such as iOS are not considered.</p>
<h2 id="aar-dependency-graph"><a class="header" href="#aar-dependency-graph">AAR Dependency Graph</a></h2>
<p>We publish a separate AAR for each component (e.g. fxaclient, places, logins) which contains
<em>just</em> the Kotlin wrappers that expose the relevant functionality to Android. Each of these AARs depends on a separate
shared &quot;megazord&quot; AAR in which all the rust code has been compiled together into a single <code>.so</code> file.
The application's dependency graph thus looks like this:</p>
<p><a href="https://docs.google.com/drawings/d/1owo4wo2F1ePlCq2NS0LmAOG4jRoT_eVBahGNeWHuhJY/"><img src="https://docs.google.com/drawings/d/e/2PACX-1vTA6wL3ibJRNjKXsmescTfKTx0w_fpr5NcDIF_4T5AsnZfCi8UEEcav8vibocSyKpHOQOk5ysiDBm-D/pub?w=727&amp;h=546" alt="megazord dependency diagram" /></a></p>
<p>This generates a kind of strange inversion of dependencies in our build pipeline:</p>
<ul>
<li>Each individual component defines both a rust crate and an Android AAR.</li>
<li>There is a special &quot;full-megazord&quot; component that also defines a rust crate and an Android AAR.</li>
<li>The full-megazord rust crate depends on the rust crates for each individual component.</li>
<li>But the Android AAR for each component depends on the Android AAR of the full-megazord!</li>
</ul>
<p>It's a little odd, but it has the benefit that we can use gradle's dependency-replacement features to easily
manage the rust code that is shipping in each application.</p>
<h2 id="custom-megazords"><a class="header" href="#custom-megazords">Custom Megazords</a></h2>
<p>By default, an application that uses <em>any</em> appservices component will include the compiled rust code
for <em>all</em> appservices components.</p>
<p>To reduce its overall code size, the application can use gradle's <a href="https://docs.gradle.org/current/userguide/customizing_dependency_resolution_behavior.html#sec:module_replacement">module replacement
rules</a>
to replace the &quot;full-megazord&quot; AAR with a custom-built megazord AAR containing only the components it requires.
Such an AAR can be built in the same way as the &quot;full-megazord&quot;, and simply avoid depending on the rust
crates for components that are not required.</p>
<p>To help ensure this replacement is done safely at runtime, the <code>mozilla.appservices.support.native</code> package
provides helper functions for loading the correct megazord <code>.so</code> file.  The Kotlin wrapper for each component
should load its shared library by calling <code>mozilla.appservices.support.native.loadIndirect</code>, specifying both
the name of the component and the expected version number of the shared library.</p>
<h2 id="unit-tests"><a class="header" href="#unit-tests">Unit Tests</a></h2>
<p>The full-megazord AAR contains compiled rust code that targets various Android platforms, and is not
suitable for running on a Desktop development machine. In order to support integration with unittest
suites such as robolectric, each megazord has a corresponding Java ARchive (JAR) distribution named e.g.
<code>full-megazord-forUnitTests.jar</code>. This contains the rust code compiled for various Desktop architectures,
and consumers can add it to their classpath when running tests on a Desktop machine.</p>
<h2 id="gotchas-and-rough-edges"><a class="header" href="#gotchas-and-rough-edges">Gotchas and Rough Edges</a></h2>
<p>This setup mostly works, but has a handful of rough edges.</p>
<p>The <code>build.gradle</code> for each component needs to declare an explicit dependency on <code>project(&quot;:full-megazord&quot;)</code>,
otherwise the resulting AAR will not be able to locate the compiled rust code at runtime. It also needs to
declare a dependency between its build task and that of the full-megazord, for reasons. Typically this looks something
like:</p>
<pre><code>tasks[&quot;generate${productFlavor}${buildType}Assets&quot;].dependsOn(project(':full-megazord').tasks[&quot;cargoBuild&quot;])
</code></pre>
<p>In order for unit tests to work correctly, the <code>build.gradle</code> for each component needs to add the <code>rustJniLibs</code>
directory of the full-megazord project to its <code>srcDirs</code>, otherwise the unittests will not be able to find and load
the compiled rust code. Typically this looks something like:</p>
<pre><code>test.resources.srcDirs += &quot;${project(':full-megazord').buildDir}/rustJniLibs/desktop&quot;
</code></pre>
<p>The above also means that unittests will not work correctly when doing local composite builds,
because it's unreasonable to expect the main project (e.g. Fenix) to include the above in its build scripts.</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/application-services/edit/main/docs/design/megazords.md">Edit this file on GitHub.</a></footer><div style="break-before: page; page-break-before: always;"></div><h1 id="sync-manager"><a class="header" href="#sync-manager">Sync manager</a></h1>
<p>We've identified the need for a &quot;sync manager&quot; (although are yet to identify a
good name for it!) This manager will be responsible for managing &quot;global sync
state&quot; and coordinating each engine.</p>
<p>At a very high level, the sync manager is responsible for all syncing. So far,
so obvious. However, given our architecture, it's possible to identify a
key architectural split.</p>
<ul>
<li>
<p>The embedding application will be responsible for most high-level operations.
For example, the app itself will choose how often regular syncs should
happen, what environmental concerns apply (eg, should I only sync on WiFi?),
letting the user choose exactly what to sync, and so forth.</p>
</li>
<li>
<p>A lower-level component will be responsible for the direct interaction with
the engines and with the various servers needed to perform a sync. It will
also have the ultimate responsibility to not cause harm to the service (for
example, it will be likely to enforce some kind of rate limiting or ensuring
that service requests for backoff are enforced)</p>
</li>
</ul>
<p>Because all application-services engines are written in Rust, it's tempting to
suggest that this lower-level component also be written in Rust and everything
&quot;just works&quot;, but there are a couple of complications here:</p>
<ul>
<li>
<p>For iOS, we hope to integrate with older engines which aren't written in
Rust, even if iOS does move to the new Sync Manager.</p>
</li>
<li>
<p>For Desktop, we hope to start by reusing the existing &quot;sync manager&quot;
implemented by Desktop, and start moving individual engines across.</p>
</li>
<li>
<p>There may be some cross-crate issues even for the Rust implemented engines.
Or more specifically, we'd like to avoid assuming any particular linkage or
packaging of Rust implemented engines.</p>
</li>
</ul>
<p>Even with these complications, we expect there to be a number of high-level
components, each written in a platform specific language (eg, Kotlin or Swift)
and a single lower-level component to be implemented in Rust and delivered
as part of the application-services library - but that's not a free-pass.</p>
<p>Why &quot;a number of high-level components&quot;? Because that is the thing which
understands the requirements of the embedding application. For example, Android
may end up with a single high-level component in the android-components repo
and shared between all Android components. Alternatively, the Android teams
may decide the sync manager isn't generic enough to share, so each app will
have their own. iOS will probably end up with its own and you could imagine
a future where Desktop does too - but they should all be able to share the
low level component.</p>
<h1 id="the-responsibilities-of-the-sync-manager"><a class="header" href="#the-responsibilities-of-the-sync-manager">The responsibilities of the Sync Manager.</a></h1>
<p>The primary responsibilities of the &quot;high level&quot; portion of the sync manager are:</p>
<ul>
<li>
<p>Manage all FxA interaction. The low-level component will have a way to
communicate auth related problems, but it is the high-level component
which takes concrete FxA action.</p>
</li>
<li>
<p>Expose all UI for the user to choose what to sync and coordinate this with
the low-level component. Note that because these choices can be made on any
connected device, these choices must be communicated in both directions.</p>
</li>
<li>
<p>Implement timers or any other mechanism to fully implement the &quot;sync
scheduler&quot;, including any policy decisions such as only syncing on WiFi,
etc.</p>
</li>
<li>
<p>Implement a UI so the user can &quot;sync now&quot;.</p>
</li>
<li>
<p>Collect telemetry from the low-level component, probably augment it, then
submit it to the telemetry pipeline.</p>
</li>
</ul>
<p>The primary responsibilities of the &quot;low level&quot; portion of the sync manager are:</p>
<ul>
<li>
<p>Manage the <code>meta/global</code>, <code>crypto/keys</code> and <code>info/collections</code> resources,
and interact with each engine as necessary based on the content of these
resources.</p>
</li>
<li>
<p>Manage interaction with the token server.</p>
</li>
<li>
<p>Enforce constraints necessary to ensure the entire ecosystem is not
subject to undue load. For example, this component should ignore attempts to
sync continuously, or to sync when the services have requested backoff.</p>
</li>
<li>
<p>Manage the &quot;clients&quot; collection - we probably can't ignore this any longer,
especially for bookmarks (as desktop will send a wipe command on bookmark
restore, and things will &quot;be bad&quot; if we don't see that command).</p>
</li>
<li>
<p>Define a minimal &quot;service state&quot; so certain things can be coordinated with
the high-level component. Examples of these states are &quot;everything seems ok&quot;,
&quot;the service requested we backoff for some period&quot;, &quot;an authentication error
occurred&quot;, and possibly others.</p>
</li>
<li>
<p>Perform, or coordinate, the actual sync of the rust implemented engines -
from the containing app's POV, there's a single &quot;sync now&quot; entry-point (in
practice there might be a couple, but conceptually there's a single way to
sync). Note that as below, how non-rust implemented engines are managed is
TBD.</p>
</li>
<li>
<p>Manage the collection of (but <em>not</em> the submission of) telemetry from the
various engines.</p>
</li>
<li>
<p>Expose APIs and otherwise coordinate with the high-level component.</p>
</li>
</ul>
<p>Stuff we aren't quite sure where it fits include:</p>
<ul>
<li>Coordination with non-rust implemented engines. These engines are almost
certainly going to be implemented in the same language as the high-level
component, which will make integration simpler. However, the low-level
component will almost certainly need some information about these engines for
populating info/collections etc. For now, we are punting on this until things
become a bit clearer.</li>
</ul>
<h1 id="implementation-details"><a class="header" href="#implementation-details">Implementation Details.</a></h1>
<p>The above has been carefully written to try and avoid implementation details -
the intent is that it's an overview of the architecture without any specific
implementation decisions.</p>
<p>These next sections start getting specific, so implementation choices need to
be made, and thus will possibly be more contentious.</p>
<p>In other words, get your spray-cans ready because there's a bikeshed being built!</p>
<p>However, let's start small and make some general observations.</p>
<h2 id="current-implementations-and-challenges-with-the-rust-components"><a class="header" href="#current-implementations-and-challenges-with-the-rust-components">Current implementations and challenges with the Rust components</a></h2>
<ul>
<li>
<p>Some apps only care about a subset of the engines - lockbox is one such app
and only cares about a single collection/engine. It might be the case that
lockbox uses a generic application-services library with many engines
available, even though it only wants logins. Thus, the embedding application
is the only thing which knows which engines should be considered to &quot;exist&quot;.
It may be that the app layer passes an engine to the sync manager, or the
sync manager knows via some magic how to obtain these handles.</p>
</li>
<li>
<p>Some apps will use a combination of Rust components and &quot;legacy&quot;
engines. For example, iOS is moving some of the engines to using Rust
components, while other engines will be ported after delivery of the
sync manager, if they are ported at all. We also plan
to introduce some rust engines into desktop without integrating the
&quot;sync manager&quot;</p>
</li>
<li>
<p>The rust components themselves are designed to be consumed as individual
components - the &quot;logins&quot; component doesn't know anything about the
&quot;bookmarks&quot; component.</p>
</li>
</ul>
<p>There are a couple of gotchyas in the current implementations too - there's an
issue when certain engines don't yet appear in meta/global - see bug 1479929
for all the details.</p>
<p>The tl;dr of the above is that each rust component should be capable of
working with different sync managers. That said though, let's not over-engineer
this and pretend we can design a single, canonical thing that will not need
changing as we consider desktop and iOS.</p>
<h2 id="state-state-and-more-state-and-then-some-state"><a class="header" href="#state-state-and-more-state-and-then-some-state">State, state and more state. And then some state.</a></h2>
<p>There's loads of state here. The app itself has some state. The high-level
Sync Manager component will have state, the low-level component will have state,
and each engine has state. Some of this state will need to be persisted (either
on the device or on the storage servers) and some of this state can be considered
ephemeral and lives only as long as the app.</p>
<p>A key challenge will be defining this state in a coherent way with clear
boundaries between them, in an effort to allow decoupling of the various bits
so Desktop and iOS can fit into this world.</p>
<p>This state management should also provide the correct degree of isolation for
the various components. For example, each engine should only know about state
which directly impacts how it works. For example, the keys used to encrypt
a collection should only be exposed to that specific engine, and there's no
need for one engine to know what info/collections returns for other engines,
nor whether the device is currently connected to WiFi.</p>
<p>A thorn here is for persisted state - it would be ideal if the low-level
component could avoid needing to persist any state, so it can avoid any
kind of storage abstraction. We have a couple of ways of managing this:</p>
<ul>
<li>
<p>The state which needs to be persisted is quite small, so we could delegate
state storage to the high-level component in an opaque way, as this
high-level component almost certainly already has storage requirements, such
as storing the &quot;choose what to sync&quot; preferences.</p>
</li>
<li>
<p>The low-level component could add its own storage abstraction. This would
isolate the high-level component from this storage requirement, but would
add complexity to the sync manager - for example, it would need to be passed
a directory where it should create a file or database.</p>
</li>
</ul>
<p>We'll probably go with the former.</p>
<h1 id="implementation-plan-for-the-low-level-component"><a class="header" href="#implementation-plan-for-the-low-level-component">Implementation plan for the low-level component.</a></h1>
<p>Let's try and move into actionable decisions for the implementation. We expect
the implementation of the low-level component to happen first, followed very
closely by the implementation of the high-level component for Android. So we
focus first on these.</p>
<h2 id="clients-engine"><a class="header" href="#clients-engine">Clients Engine</a></h2>
<p>The clients engine includes some meta-data about each client. We've decided
we can't replace the clients engine with the FxA device record and we can't
simply drop this engine entirely.</p>
<p>Of particular interest is &quot;commands&quot; - these involve communicating with the
engine regarding commands targetting it, and accepting commands to be send to
other devices. Note that outgoing commands are likely to not originate from a sync,
but instead from other actions, such as &quot;restore bookmarks&quot;.</p>
<p>However, because the only current requirement for commands is to wipe the
store, and because you could anticipate &quot;wipe&quot; also being used when remotely
disconnecting a device (eg, when a device is lost or stolen), our lives would
probably be made much simpler by initially supporting only per-engine wipe
commands.</p>
<p>Note that there has been some discussion about not implementing the client
engine and replacing &quot;commands&quot; with some other mechanism. However, we have
decided to not do that because the implementation isn't considered too
difficult, and because desktop will probably require a number of changes to
remove it (eg, &quot;synced tabs&quot; will not work correctly without a client record
with the same guid as the clients engine.)</p>
<p>Note however that unlike desktop, we will use the FxA device ID as the client
ID. Because FxA device IDs are more ephemeral than sync IDs, it will be
necessary for engines using this ID to track the most-recent ID they synced
with so the old record can be deleted when a change is detected.</p>
<h2 id="collections-vs-engines-vs-stores-vs-preferences-vs-apis"><a class="header" href="#collections-vs-engines-vs-stores-vs-preferences-vs-apis">Collections vs engines vs stores vs preferences vs Apis</a></h2>
<p>For the purposes of the sync manager, we define:</p>
<ul>
<li>
<p>An <em>engine</em> is the unit exposed to the user - an &quot;engine&quot; can be enabled
or disabled. There is a single set of canonical &quot;engines&quot; used across the
entire sync ecosystem - ie, desktop and mobile devices all need to agree
about what engines exist and what the identifier for an engine is.</p>
</li>
<li>
<p>An <em>Api</em> is the unit exposed to the application layer for general application
functionality. Application services has 'places' and 'logins' Apis and is
the API used by the application to store and fetch items. Each 'Api' may
have one or more 'stores' (although the application layer will generally not
interact directly with a store)</p>
</li>
<li>
<p>A <em>store</em> is the code which actually syncs. This is largely an implementation
detail. There may be multiple stores per engine (eg, the &quot;history&quot; engine
may have &quot;history&quot; and &quot;forms&quot; stores) and a single 'Api' may expose multiple
stores (eg, the &quot;places Api&quot; will expose history and bookmarks stores)</p>
</li>
<li>
<p>A <em>collection</em> is a unit of storage on a server. It's even more of an
implementation detail than a store. For example, you might imagine a future
where the &quot;history&quot; store uses multiple &quot;collections&quot; to help with containers.</p>
</li>
</ul>
<p>In practice, this means that the high-level component should only need to care
about an <em>engine</em> (for exposing a choice of what to sync to the user) and an
<em>api</em> (for interacting with the data managed by that api). The low-level
component will manage the mapping of engines to stores.</p>
<h2 id="the-declined-list"><a class="header" href="#the-declined-list">The declined list</a></h2>
<p>This document isn't going to outline the history of how &quot;declined&quot; is used, nor
talk about how this might change in the future. For the purposes of the sync
manager, we have the following hard requirements:</p>
<ul>
<li>
<p>The low-level component needs to know what the currently declined set of
engines is for the purposes of re-populating <code>meta/global</code>.</p>
</li>
<li>
<p>The low-level component needs to know when the declined set needs to change
based on user input (ie, when the user opts in to or out of a particular
engine on this device)</p>
</li>
<li>
<p>The high-level component needs to be aware that the set of declined engines
may change on every sync (ie, when the user opts in to or out of a particular
engine on another device)</p>
</li>
</ul>
<p>A complication is that due to networks being unreliable, there's an inherent
conflict between &quot;what is the current state?&quot; and &quot;what state changes are
requested?&quot;. For example, if the user changes the state of an engine while
there's no network, then exits the app, how do we ensure the user's new state
is updated next time the app starts? What if the user has since made a
different state request on a different device? Is the state as last-known on
this device considered canonical?</p>
<p>To clarify, consider:</p>
<ul>
<li>
<p>User on this device declines logins. This device now believes logins is
disabled but history is enabled, but is unable to write this to the server
due to no network.</p>
</li>
<li>
<p>The user declines history on a different device, but doesn't change logins.
This device does manage to write the new list to the server.</p>
</li>
<li>
<p>This device restarts and the network is up. It believes history is enabled
but logins is not - however, the state on the server is the exact opposite.</p>
</li>
</ul>
<p>How does this device react?</p>
<p>(On the plus side, this is an extreme edge-case which none of our existing
implementations handle &quot;correctly&quot; - which is easy to say, because there's
no real definition for &quot;correctly&quot;)</p>
<p>Regardless, the low-level component will not pretend to hide this complexity
(ie, it will ignore it!). The low-level component will allow the app to ask
for state changes as part of a sync, and will return what's on the server at
the end of every sync. The app is then free to build whatever experience
it desires around this.</p>
<h2 id="disconnecting-from-sync"><a class="header" href="#disconnecting-from-sync">Disconnecting from Sync</a></h2>
<p>The low-level component needs to have the ability to disconnect all engines
from Sync. Engines which are declined should also be reset.</p>
<p>Because we will need wipe() functionality to implement the clients engine,
and because Lockbox wants to wipe on disconnect, we will provide disconnect
and wipe functionality.</p>
<h1 id="specific-deliverables-for-the-low-level-component"><a class="header" href="#specific-deliverables-for-the-low-level-component">Specific deliverables for the low-level component.</a></h1>
<p>Breaking the above down into actionable tasks which can be some somewhat
concurrently, we will deliver:</p>
<h2 id="the-api"><a class="header" href="#the-api">The API</a></h2>
<p>A straw-man for the API we will expose to the high-level components. This
probably isn't too big, but we should do this as thoroughly as we can. In
particular, ensure we have covered:</p>
<ul>
<li>
<p>Declined management - how the app changes the declined list and how it learns
of changes from other devices.</p>
</li>
<li>
<p>How telemetry gets handed from the low-level to the high-level.</p>
</li>
<li>
<p>The &quot;state&quot; - in particular, how the high-level component understands the
auth state is wrong, and whether the service is in a degraded mode (eg,
server requested backoff)</p>
</li>
<li>
<p>How the high-level component might specify &quot;special&quot; syncs, such as &quot;just
one engine&quot; or &quot;this is a pre-sleep, quick-as-possible sync&quot;, etc</p>
</li>
</ul>
<p>There's a straw-man proposal for this at the end of the document.</p>
<h2 id="a-command-line-and-possibly-android-utility"><a class="header" href="#a-command-line-and-possibly-android-utility">A command-line (and possibly Android) utility.</a></h2>
<p>We should build a utility (or 2) which can stand in for the high-level
component, for testing and demonstration purposes.</p>
<p>This is something like places-utils.rs and the little utility Grisha has
been using. This utility should act like a real client (ie, it should have
an FxA device record, etc) and it should use the low-level component in
exactly the same we we expect real products to use it.</p>
<p>Because it is just a consumer of the low-level component, it will force us to
confront some key issues, such as how to get references to engines stored in
multiple crates, how to present a unified &quot;state&quot; for things like auth errors,
etc.</p>
<h2 id="the-clients-engine"><a class="header" href="#the-clients-engine">The &quot;clients&quot; engine</a></h2>
<p>The initial work for the clients engine can probably be done without too
much regard for how things are tied together - for example, much work could
be done without caring how we get a reference to engines across crates.</p>
<h2 id="state-work"><a class="header" href="#state-work">State work</a></h2>
<p>Implementing things needed to we can expose the correct state to the high-level
manager for things like auth errors, backoff semantics, etc</p>
<h2 id="tie-it-together-and-other-misc-things"><a class="header" href="#tie-it-together-and-other-misc-things">Tie it together and other misc things.</a></h2>
<p>There will be lots of loose ends to clean up - things like telemetry, etc.</p>
<h1 id="followup-with-non-rust-engines"><a class="header" href="#followup-with-non-rust-engines">Followup with non-rust engines.</a></h1>
<p>We have identified that iOS will, at least in the short term, want the
sync manager to be implemented in Swift. This will be responsible for
syncing both the Swift and Rust implemented engines.</p>
<p>At some point in the future, Desktop may do the same - we will have both
Rust and JS implemented engines which need to be coordinated. We ignore this
requirement for now.</p>
<p>This approach still has a fairly easy time coordinating with the Rust
implemented engines - the FFI will need to expose the relevant sync
entry-points to be called by Swift, but the Swift code can hard-code the
Rust engines it has and make explicit calls to these entry-points.</p>
<p>This Swift code will need to create the structures identified below, but this
shouldn't be too much of a burden as it already has the information necessary
to do so (ie, it already has info/collections etc)</p>
<p>TODO: dig into the Swift code and make sure this is sane.</p>
<h1 id="details"><a class="header" href="#details">Details</a></h1>
<p>While we use rust struct definitions here, it's important to keep in mind that
as mentioned above, we'll need to support the manager being written in
something other than rust, and to support engines written in other than rust.</p>
<p>The structures below are a straw-man, but hopefully capture all the information
that needs to be passed around.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>// We want to define a list of &quot;engine IDs&quot; - ie, canonical strings which
// refer to what the user perceives as an &quot;enigine&quot; - but as above, these
// *do not* correspond 1:1 with either &quot;stores&quot; or &quot;collections&quot; (eg, &quot;history&quot;
// refers to 2 stores, and in a future world, might involve 3 collections).
enum Engine {
  History, // The &quot;History&quot; and &quot;Forms&quot; stores.
  Bookmarks, // The &quot;Bookmark&quot; store.
  Passwords,
}

impl Engine {
  fn as_str(&amp;self) -&gt; &amp;'static str {
    match self {
      History =&gt; &quot;history&quot;,
      // etc
  }
}

// A struct which reflects engine declined states.
struct EngineState {
  engine: Engine,
  enabled: bool,
}

// A straw-man for the reasons why a sync is happening.
enum SyncReason {
  Scheduled,
  User,
  PreSleep,
  Startup,
}

// A straw man for the general status.
enum ServiceStatus {
  Ok,
  // Some general network issue.
  NetworkError,
  // Some apparent issue with the servers.
  ServiceError,
  // Some external FxA action needs to be taken.
  AuthenticationError,
  // We declined to do anything for backoff or rate-limiting reasons.
  BackedOff,
  // Something else - you need to check the logs for more details.
  OtherError,
}

// Info we need from FxA to sync. This is roughly our Sync15StorageClientInit
// structure with the FxA device ID.
struct AccountInfo {
  key_id: String,
  access_token: String,
  tokenserver_url: Url,
  device_id: String,
}

// Instead of massive param and result lists, we use structures.
// This structure is passed to each and every sync.
struct SyncParams {
  // The engines to Sync. None means &quot;sync all&quot;
  engines: Option&lt;Vec&lt;Engine&gt;&gt;,
  // Why this sync is being done.
  reason: SyncReason,

  // Any state changes which should be done as part of this sync.
  engine_state_changes: Vec&lt;EngineState&gt;,

  // An opaque state &quot;blob&quot;. This should be persisted by the app so it is
  // reused next sync.
  persisted_state: Option&lt;String&gt;,
}

struct SyncResult {
  // The general health.
  service_status: ServiceStatus,

  // The result for each engine.
  engine_results: HashMap&lt;Engine, Result&lt;()&gt;&gt;,

  // The list of declined engines, or None if we failed to get that far.
  declined_engines: Option&lt;Vec&lt;Engine&gt;&gt;,

  // When we are allowed to sync again. If &gt; now() then there's some kind
  // of back-off. Note that it's not strictly necessary for the app to
  // enforce this (ie, it can keep asking us to sync, but we might decline).
  // But we might not too - eg, we might try a user-initiated sync.
  next_sync_allowed_at: Timestamp,

  // New opaque state which should be persisted by the embedding app and supplied
  // the next time Sync is called.
  persisted_state: String,

  // Telemetry. Nailing this down is tbd.
  telemetry: Option&lt;JSONValue&gt;,
}

struct SyncManager {}

impl SyncManager {
  // Initialize the sync manager with the set of Engines known by this
  // application without regard to the enabled/declined states.
  // XXX - still TBD is how we will pass &quot;stores&quot; around - it may be that
  // this function ends up taking an `impl Store`
  fn init(&amp;self, engines: Vec&lt;&amp;str&gt;) -&gt; Result&lt;()&gt;;

  fn sync(&amp;self, params: SyncParams) -&gt; Result&lt;SyncResult&gt;;

  // Interrupt any current syncs. Note that this can be called from a different
  // thread.
  fn interrupt() -&gt; Result&lt;()&gt;;

  // Disconnect this device from sync. This may &quot;reset&quot; the stores, but will
  // not wipe local data.
  fn disconnect(&amp;self) -&gt; Result&lt;()&gt;;

  // Wipe all local data for all local stores. This can be done after
  // disconnecting.
  // There's no exposed way to wipe the remote store - while it's possible
  // stores will want to do this, there's no need to expose this to the user.
  fn wipe(&amp;self) -&gt; Result&lt;()&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/application-services/edit/main/docs/design/sync-manager.md">Edit this file on GitHub.</a></footer><div style="break-before: page; page-break-before: always;"></div><h1 id="sync-overview"><a class="header" href="#sync-overview">Sync Overview</a></h1>
<p>This document provides a high-level overview of how syncing works.  <strong>Note</strong>: each component has its own quirks and will handle sync slightly differently than the general process described here.</p>
<h2 id="general-flow-and-architecture"><a class="header" href="#general-flow-and-architecture">General flow and architecture</a></h2>
<ul>
<li><strong>Crates involved</strong>:
<ul>
<li>The <code>sync15</code> and <code>support/sync15-traits</code> handle the general syncing logic and define the <code>SyncEngine</code> trait</li>
<li>Individual component crates (<code>logins</code>, <code>places</code>, <code>autofill</code>, etc).  These implement <code>SyncEngine</code>.</li>
<li><code>sync_manager</code> manages the overall syncing process.</li>
</ul>
</li>
<li><strong>High level sync flow</strong>:
<ul>
<li>Sync is initiated by the application that embeds application-services.</li>
<li>The application calls <code>SyncManager.sync()</code> to start the sync process.</li>
<li><code>SyncManager</code> creates <code>SyncEngine</code> instances to sync the individual components.  Each <code>SyncEngine</code> corresponds to a <code>collection</code> on the sync server.</li>
</ul>
</li>
</ul>
<h3 id="sync-manager-1"><a class="header" href="#sync-manager-1">Sync manager</a></h3>
<p><a href="https://github.com/mozilla/application-services/blob/main/components/sync_manager/src/manager.rs"><code>SyncManager</code></a> is responsible for performing the high-level parts of the sync process:</p>
<ul>
<li>The consumer code calls it's <code>sync()</code> function to start the sync, passing
in a <a href="https://mozilla.github.io/application-services/rust-docs/sync_manager/msg_types/struct.SyncParams.html"><code>SyncParams</code></a> object in, which describes what should be synced.</li>
<li><code>SyncManager</code> performs all network operations on behalf of the individual engines. It's also responsible for tracking the general authentication state (primarily by inspecting the responses from these network requests) and fetching tokens from the token server.</li>
<li><code>SyncManager</code> checks if we are currently in a backoff period and should wait before contacting the server again.</li>
<li>Before syncing any engines, the sync manager checks the state of the meta/global collection and compares it with the enabled engines specified in the SyncParams.  This handles the cases when the user has requested an engine be enabled or disabled on this device, or when it was requested on a different device. (Note that engines enabled and disabled states are state on the account itself and not a per-device setting).  Part of this process is comparing the collection's GUID on the server with the GUID known locally - if they are different, it implies some other device has &quot;reset&quot; the collection, so the engine drops all metadata and attempts to reconcile with every record on the server (ie, acts as though this is the very first sync this engine has ever done).</li>
<li><code>SyncManager</code> instantiates a <code>SyncEngine</code> for each enabled component.  We currently use 2 different methods for this:
<ul>
<li>The older method is for the <code>SyncManager</code> to hold a weakref to a <code>Store</code> use that to create the <code>SyncEngine</code> (tabs and places).  The <code>SyncEngine</code> uses the <code>Store</code> for database access, see the <a href="https://mozilla.github.io/application-services/rust-docs/tabs/struct.TabsStore.html"><code>TabsStore</code></a> for an example.</li>
<li>The newer method is for the components to provide a function to create the <code>SyncEngine</code>, hiding the details of how that engine gets created (autofill/logins).  These components also define a <code>Store</code> instance for the <code>SyncEngine</code> to use, but it's all transparent to the <code>SyncManager</code>.  (See <a href="https://mozilla.github.io/application-services/rust-docs/autofill/db/store/fn.get_registered_sync_engine.html"><code>autofill::get_registered_sync_engine()</code></a> and <a href="https://mozilla.github.io/application-services/rust-docs/autofill/db/store/struct.Store.html"><code>autofill::db::store::Store</code></a>)</li>
</ul>
</li>
<li>For components that use local encryption, <code>SyncManager</code> passes the local encryption key to their <code>SyncEngine</code></li>
<li>Finally, calls <code>sync_multiple()</code> function from the <code>sync15</code> crate, sending it the <code>SyncEngine</code> instances.  <code>sync_multiple()</code> then calls the <code>sync()</code> function for each individual <code>SyncEngine</code></li>
</ul>
<h3 id="sync-engines"><a class="header" href="#sync-engines">Sync engines</a></h3>
<ul>
<li><a href="https://github.com/mozilla/application-services/blob/main/components/support/sync15-traits/src/engine.rs"><code>SyncEngine</code></a> is defined in the <code>support/sync15-traits</code> crate and defines the interface for syncing a component.</li>
<li>A new <code>SyncEngine</code> instance is created for each sync</li>
<li><code>SyncEngine.apply_incoming()</code> does the main work.  It is responsible for processing incoming records from the server in order to update the local records and calculating which local records should be synced back.</li>
</ul>
<h2 id="the-apply_incoming-pattern"><a class="header" href="#the-apply_incoming-pattern">The <code>apply_incoming</code> pattern</a></h2>
<p><code>SyncEngine</code> instances are free to implement <code>apply_incoming()</code> any way they want, but the most components follow a general pattern.</p>
<h3 id="database-tables"><a class="header" href="#database-tables">Database Tables</a></h3>
<ul>
<li>The local table stores records for the local application</li>
<li>The mirror table stores the last known record from the server</li>
<li>The staging temporary table stores the incoming records that we're currently processing</li>
<li>The local/mirror/staging tables contains a <code>guid</code> as its primary key.  A record will share the same <code>guid</code> for the local/mirror/staging table.</li>
<li>The metadata table stores the GUID for the collection as a whole and the the last-known server timestamp of the collection.</li>
</ul>
<h3 id="apply_incoming-stages"><a class="header" href="#apply_incoming-stages"><code>apply_incoming</code> stages</a></h3>
<ul>
<li><strong>stage incoming</strong>: write out each incoming server record to the staging table</li>
<li><strong>fetch states</strong>: take the rows from all 3 tables and combine them into a single struct containing <code>Option</code>s for the local/mirror/staging records.</li>
<li><strong>iterate states</strong>: loop through each state, decide how to do change the local records, then execute that plan.
<ul>
<li><strong>reconcile/plan</strong>: For each state we create an action plan for it.  The action plan is a low-level description of what to change (add this record, delete this one, modify this field, etc).  Here are some common situations:
<ul>
<li><strong>A record only appears in the staging table</strong>.  It's a new record from the server and should be added to the local DB</li>
<li><strong>A record only appears in the local table</strong>.  It's a new record on the local instance and should be synced back to the serve</li>
<li><strong>Identical records appear in the local/mirror tables and a changed record is in the staging table</strong>.  The record was updated remotely and the changes should be propagated to the local DB.</li>
<li><strong>A record appears in the mirror table and changed records appear in both the local and staging tables</strong>.  The record was updated both locally and remotely and we should perform a 3-way merge.</li>
</ul>
</li>
<li><strong>apply plan</strong>: After we create the action plan, then we execute it.</li>
</ul>
</li>
<li><strong>fetch outgoing</strong>:
<ul>
<li>Calculate which records need to be sent back to the server</li>
<li>Update the mirror table</li>
<li>Return those records back to the <code>sync15</code> code so that it can upload them to the server.</li>
<li>The sync15 code returns the timestamp reported by the server in the POST response and hands it back to the engine. The engine persists this timestamp in the metadata table - the next sync will then use this timestamp to only fetch records that have since been changed by other devices</li>
</ul>
</li>
</ul>
<h3 id="syncchangecounter"><a class="header" href="#syncchangecounter">syncChangeCounter</a></h3>
<p>The local table has an integer column syncChangeCounter which is incremented every time the embedding app makes a change to a local record (eg, updating a field). Thus, any local record with a non-zero change counter will need to be updated on the server (with either the local record being used, or after it being merged if the record also changed remotely). At the start of the sync, when we are determining what action to take, we take a copy of the change counter, typically in a temp staging table. After we have uploaded the record to the server, we decrement the counter by whatever it was when the sync started. This means that if a record is changed in between staging the record and uploading it, the change counter will not drop to zero, and so it will correctly be seen as locally modified on the next sync</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/application-services/edit/main/docs/design/sync-overview.md">Edit this file on GitHub.</a></footer><div style="break-before: page; page-break-before: always;"></div><h1 id="high-level-design-for-shipping-rust-components-as-swift-packages"><a class="header" href="#high-level-design-for-shipping-rust-components-as-swift-packages">High level design for shipping Rust Components as Swift Packages</a></h1>
<blockquote>
<p>This is a high level description of the decision highlighted in the <a href="design/../adr/0003-swift-packaging.html">ADR that introduced Swift Packages as a strategy to ship our Rust components</a>. That document includes that tradeoffs and why we chose this approach.</p>
</blockquote>
<!--
  N.B. you can edit this image in Google Docs and changes will be reflected automatically:

    https://docs.google.com/drawings/d/1tX05I-e6hNBQxch7PescDH7k4G7ddAJwXDPoIqp1RYk/edit
-->
<img src="https://docs.google.com/drawings/d/e/2PACX-1vRnyxy7VjdD3bYTso8V3AL5FpIQ4_S54dOCDI6fxfZEbG3_CVBwZZP1uLYbUVE9M54GSXUkNgewzOQm/pub?w=720&h=540" width="720" height="540" alt="A box diagram describing how the rust-components-swift repo, applicaiton-services repo, and MozillaRustComponents XCFramework interact">
<p>The strategy includes two main parts:</p>
<ul>
<li>The <a href="https://developer.apple.com/documentation/swift_packages/distributing_binary_frameworks_as_swift_packages">xcframework</a> that is built from a <a href="design/./megazords.html">megazord</a>. The xcframework contains the following, built for all our target iOS platforms.
<ul>
<li>The compiled Rust code for all the crates listed in <code>Cargo.toml</code> as a static library</li>
<li>The C header files and <a href="https://clang.llvm.org/docs/Modules.html">Swift module maps</a> for the components</li>
</ul>
</li>
<li>The <a href="https://github.com/mozilla/rust-components-swift"><code>rust-components-swift</code></a> repository which has a <code>Package.swift</code> that includes the <code>xcframework</code> and acts as the swift package the consumers import</li>
</ul>
<h2 id="the-xcframework-and-application-services"><a class="header" href="#the-xcframework-and-application-services">The xcframework and <code>application-services</code></a></h2>
<p>In <code>application-services</code>, in the <a href="https://github.com/mozilla/application-services/tree/main/megazords/ios-rust"><code>megazords/ios-rust</code></a> directory, we have the following:</p>
<ul>
<li>A Rust crate that serves as the <a href="design/./megazords.html">megazord</a> for our iOS distributions. The megazord depends on all the Rust Component crates and re-exports their public APIs.</li>
<li>Some skeleton files for building an xcframework:
<ol>
<li><a href="https://clang.llvm.org/docs/Modules.html"><code>module.modulemap</code></a>: The module map tells the Swift compiler how to use C APIs.</li>
<li><code>MozillaRustComponents.h</code>: The header is used by the module map as a shortcut to specify all the available header files</li>
<li><code>Info.plist</code>: The <code>plist</code> file specifies metadata about the resulting xcframework. For example, architectures and subdirectories.</li>
</ol>
</li>
<li>The <code>build-xcframework.sh</code> script that stitches things together into a full xcframework bundle:
<ul>
<li>The <code>xcframework</code> format is not well documented; briefly:
<ul>
<li>The xcframework is a directory containing the resources compiled for multiple target architectures. The xcframework is distributed as a <code>.zip</code> file.</li>
<li>The top-level directory contains a subdirectory per architecture and an <code>Info.plist</code>. The <code>Info.plist</code> describes what lives in which directory.</li>
<li>Each subdirectory represents an architecture. And contains a <code>.framework</code> directory for that architecture.</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>It's a little unusual that we're building the xcframework by hand, rather than defining it as the build output of an Xcode project. It turns out to be simpler for our purposes, but does risk diverging from the expected format if Apple changes the details of xcframeworks in future Xcode releases.</p>
</blockquote>
<h2 id="the-rust-components-swift-repository"><a class="header" href="#the-rust-components-swift-repository">The <code>rust-components-swift</code> repository</a></h2>
<p>The repository is a Swift Package for distributing releases of Mozilla's various Rust-based application components. It provides the Swift source code packaged in a format understood by the Swift package manager, and depends on a pre-compiled binary release of the underlying Rust code published from <code>application-services</code></p>
<p>The <code>rust-components-swift</code> repo mainly includes the following:</p>
<ul>
<li><code>Package.swift</code>: Defines all the <a href="https://developer.apple.com/documentation/swift_packages/target"><code>targets</code></a> and <a href="https://developer.apple.com/documentation/swift_packages/product"><code>products</code></a> the package exposes.
<ul>
<li><code>Package.swift</code> also includes where the package gets the <code>xcframework</code> that <code>application-services</code> builds</li>
</ul>
</li>
<li><code>make_tag.sh</code>: A script that does the following:
<ul>
<li>Generates any dynamically generated Swift code, mainly:
<ul>
<li>The <a href="https://github.com/mozilla/uniffi-rs/">uniffi</a> generated Swift bindings</li>
<li><a href="https://mozilla.github.io/glean/book/user/adding-glean-to-your-project/swift.html#setting-up-metrics-and-pings-code-generation">The Glean metrics</a></li>
</ul>
</li>
<li>Creates and commits a git tag that can be pushed to cut a release</li>
</ul>
</li>
</ul>
<blockquote>
<p>Consumers would then import the <code>rust-components-swift</code> swift package, by indicating the url of the package on github (i.e <a href="https://github.com/mozilla/rust-components-swift">https://github.com/mozilla/rust-components-swift</a>) and selecting a version using the git tag.</p>
</blockquote>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/application-services/edit/main/docs/design/swift-package-manager.md">Edit this file on GitHub.</a></footer><div style="break-before: page; page-break-before: always;"></div><h2 id="high-level-firefox-sync-interactions"><a class="header" href="#high-level-firefox-sync-interactions">High level firefox sync interactions</a></h2>
<p>On a high level, Firefox Sync has three main components:</p>
<ul>
<li>The Firefox Account Server: Which uses oauth to authenticate and provide users with scoped access. The FxA Server also stores input that will 
be used by the <strong>clients</strong> to generate the sync keys.</li>
<li>Firefox: This is the firefox app itself, which implements the client logic to communicate with the firefox account servers, generate sync keys,
use them to encrypt data and send/receive encrypted data to/from the sync 
storage servers</li>
<li>Sync Storage Server: The server that stores <strong>encrypted</strong> sync data. The clients would retrieve the encrypted data and decrypt
it <strong>client side</strong></li>
</ul>
<p>Additionally, the token server assists in providing metadata to Firefox, so that it knows which sync server to communicate with.
<img src="design/diagrams/high-level-sync-ecosystem.png" alt="Diagram showing on a high level, how Firefox sync interacts with Firefox Accounts and Sync Services" /></p>
<h2 id="multi-platform-sync-diagram"><a class="header" href="#multi-platform-sync-diagram">Multi-platform sync diagram</a></h2>
<p>Since we have multiple Firefox apps (Desktop, iOS, Android, Focus, etc) Firefox sync can sync across platforms. Allowing users
to access their up-to-date data across apps and devices.
<img src="design/diagrams/multi-platform-sync-diagram.png" alt="Diagram showing how firefox sync is a multi-platform feature" /></p>
<h3 id="before-how-sync-was"><a class="header" href="#before-how-sync-was">Before: How sync was</a></h3>
<p>Before our Rust Components came to life, each application had its own implementation of the sync and FxA client protocols.
This lead to duplicate logic across platforms. This was problematic since any modification to the sync or FxA client business logic
would need to be modified in all implementations and the likelihood of errors was high.
<img src="design/diagrams/before-cross-components.png" alt="Diagram showing how firefox sync used to be, with each platform having its own implementation" /></p>
<h3 id="now-sync-is-starting-to-streamline-its-components"><a class="header" href="#now-sync-is-starting-to-streamline-its-components">Now: Sync is starting to streamline its components</a></h3>
<p>Currently, we are in the process of migrating many of the sync implementation to use our Rust Component strategy.
Fenix primarily uses our Rust Components and iOS has some integrated as well. Additionally, Firefox Desktop also uses
one Rust component (Web Extension Storage).</p>
<p>The Rust components not only unify the different implementations of sync, they also provide a convenient local storage for the apps.
In other words, the apps can use the components for storage, with or without syncing to the server.
<img src="design/diagrams/now-cross-components.png" alt="Diagram showing how firefox sync is now, with iOS and Fenix platform sharing some implementations" /></p>
<h4 id="current-status"><a class="header" href="#current-status">Current Status</a></h4>
<p>The following table has the status of each of our sync Rust Components
| Application\Component | Bookmarks | History | Tabs | Passwords | Autofill | Web Extension Storage | FxA Client |
|-----------------------|-----------|---------|------|-----------|----------|-----------------------|------------|
| Fenix                 | ✔️         | ✔️       | ✔️    | ✔️         | ✔️        |                       | ✔️          |
| Firefox iOS           | ✔️         |         |      | ✔️         |          |                       | ✔️          |
| Firefox Desktop       |           |         |      |           |          | ✔️                     |            |
| Focus                 |           |         |      |           |          |                       |            |</p>
<h3 id="future-only-one-implementation-for-each-sync-engine"><a class="header" href="#future-only-one-implementation-for-each-sync-engine">Future: Only one implementation for each sync engine</a></h3>
<p>In an aspirational future, all the applications would use the same implementation for Sync.
However, it's unlikely that we would migrate everything to use the Rust components since some implementations 
may not be prioritized, this is especially true for desktop which already has stable implementations.
That said, we can get close to this future and minimize duplicate logic and the likelihood of errors.
<img src="design/diagrams/future-cross-components.png" alt="Diagram showing how firefox sync should be, with all platforms using one implementation" /></p>
<p>You can edit the diagrams in the following lucid chart (Note: Currently only Mozilla Employees can edit those diagrams): https://lucid.app/lucidchart/invitations/accept/inv_ab72e218-3ad9-4604-a7cd-7e0b0c259aa2</p>
<p>Once they are edited, you can re-import them here by replacing the old diagrams in the <code>docs/diagrams</code> directory on GitHub. As long as the
names are the same, you shouldn't need to edit those docs!</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/application-services/edit/main/docs/design/components-strategy.md">Edit this file on GitHub.</a></footer><div style="break-before: page; page-break-before: always;"></div><h2 id="metrics-collected-by-application-services-components"><a class="header" href="#metrics-collected-by-application-services-components">Metrics collected by Application Services components</a></h2>
<p>Some application-services components collect telemetry using the <a href="https://mozilla.github.io/glean/">Glean SDK</a>.</p>
<p>Products that send telemetry via Glean <em>must request</em> a data-review following
<a href="https://wiki.mozilla.org/Firefox/Data_Collection">the Firefox Data Collection process</a>
before integrating any of the components listed below.</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/application-services/edit/main/docs/design/metrics.md">Edit this file on GitHub.</a></footer><div style="break-before: page; page-break-before: always;"></div><h1 id="rust-versions"><a class="header" href="#rust-versions">Rust Versions</a></h1>
<p>Like almost all Rust projects, the entire point of the application-services
components is that they be used by external projects. If these components
use Rust features available in only the very latest Rust version, this will
cause problems for projects which aren't always able to be on that latest
version.</p>
<p>Given application-services is currently developed and maintained by Mozilla
staff, it should be no surprise that an important consideration is
mozilla-central (aka, the main Firefox repository).</p>
<h2 id="mozilla-central-rust-policies"><a class="header" href="#mozilla-central-rust-policies">Mozilla-central Rust policies.</a></h2>
<p>It should also come as no surprise that the Rust policy for mozilla-central
is somewhat flexible. There is an official <a href="https://firefox-source-docs.mozilla.org/writing-rust-code/update-policy.html">Rust Update Policy Document
</a>
but everything in the future is documented as &quot;estimated&quot;.</p>
<p>Ultimately though, that page defines 2 Rust versions - &quot;Uses&quot; and &quot;Requires&quot;,
and our policy revolves around these.</p>
<h1 id="application-services-rust-version-policy"><a class="header" href="#application-services-rust-version-policy">application-services Rust version policy</a></h1>
<p>Our official Rust version policy is:</p>
<ul>
<li>
<p>All components will ship using, have all tests passing, and have clippy emit
no warnings, with the same version mozilla-central currently &quot;uses&quot;.</p>
</li>
<li>
<p>All components  must be capable of building (although not necessarily with
all tests passing nor without clippy errors or other warnings) with the same
version mozilla-central currently &quot;requires&quot;.</p>
</li>
<li>
<p>This policy only applies to the &quot;major&quot; and &quot;minor&quot; versions - a different
patch level is still considered compliant with this policy.</p>
</li>
</ul>
<h2 id="implications-of-this"><a class="header" href="#implications-of-this">Implications of this</a></h2>
<p>All CI for this project will try and pin itself to this same version. At
time of writing, this means that <a href="https://github.com/mozilla/application-services/blob/main/.circleci/config.yml">our circle CI integration
</a> and
<a href="https://github.com/mozilla/application-services/blob/main/rust-toolchain">rust-toolchain configuration</a>
will specify the versions (and where possible, the CI configuration file will
avoid duplicating the information in <code>rust-toolchain</code>)</p>
<p>We should maintain CI to ensure we still build with the &quot;Requires&quot; version.</p>
<p>As versions inside mozilla-central change, we will bump these versions
accordingly. While newer versions of Rust can be expected to work correctly
with our existing code, it's likely that clippy will complain in various ways
with the new version. Thus, a PR to bump the minimum version is likely to also
require a PR to make changes which keep clippy happy.</p>
<p>In the interests of avoiding redundant information which will inevitably
become stale, the circleci and rust-toolchain configuration links above
should be considered the canonical source of truth for the currently supported
official Rust version.</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/application-services/edit/main/docs/design/rust-versions.md">Edit this file on GitHub.</a></footer><div style="break-before: page; page-break-before: always;"></div><h1 id="application-services-release-process"><a class="header" href="#application-services-release-process">Application Services Release Process</a></h1>
<h2 id="make-a-new-release-from-latest-main"><a class="header" href="#make-a-new-release-from-latest-main">Make a new release from latest main.</a></h2>
<ol>
<li>
<p>Create a release commit.</p>
<ul>
<li>
<p><strong>Automated process:</strong> run the <code>./automation/prepare-release.py</code> script to create a release commit and open a pull-request.</p>
<p>Note that after this script is executed, the following should be true:</p>
<ul>
<li>The library version has been updated in <code>.buildconfig-android.yml</code>.</li>
<li>The entries in <code>CHANGES_UNRELEASED.md</code> have been moved to <code>CHANGELOG.md</code> under a header with the new version number and a link to the full changelog since the previous release.</li>
<li>The full changelog link in <code>CHANGES_UNRELEASED.md</code> has been updated with the new release version.</li>
</ul>
</li>
<li>
<p><strong>Manual process:</strong> if the automated process above fails, refer to the <a href="howtos/cut-a-new-release.html#create-a-release-commit-manually">Create a release commit manually</a> section.</p>
</li>
</ul>
<p><strong>Note:</strong> Because the release commit must be on the main branch, your PR will need to be approved, CI successful, and merged before a release can be cut.</p>
</li>
<li>
<p>Cut the actual release.</p>
<ol>
<li>Click &quot;Releases&quot;, and then &quot;Draft a New Release&quot; in the github UI.</li>
<li>Enter <code>v&lt;myversion&gt;</code> as the tag. It's important this is the same as the tags that are in the changelog.</li>
<li>Under the description, paste the contents of the release notes from CHANGELOG.md.</li>
<li>Note that the release is not avaliable until the taskcluster build completes for that tag.
<ul>
<li>Finding this out takes a little navigation in the github UI. It's available at <code>https://github.com/mozilla/application-services/commits/v&lt;VERSION NUMBER&gt;</code> in the build status info (the emoji) next to the last commit.</li>
<li>If the taskcluster tag and/or release tasks fail, ping someone in slack and we'll figure out what to do.</li>
</ul>
</li>
<li>Click &quot;Publish Release&quot;.</li>
</ol>
</li>
<li>
<p>Inform consumers that the new release is available so that <a href="https://github.com/mozilla-mobile/android-components">android-components</a> can be updated. If you will be creating the update, do the following:</p>
<ol>
<li>If the changes expose new functionality, or otherwise require changes to code or documentation in https://github.com/mozilla-mobile/android-components, perform those. This part is often done at the same time as the changes in application-services, to avoid being blocked on steps 3-4 of this document.</li>
<li>Change the versions of our dependencies in <a href="https://github.com/mozilla-mobile/android-components/blob/master/buildSrc/src/main/java/Dependencies.kt">buildSrc/src/main/java/Dependencies.kt</a>.</li>
<li>Note the relevant changes in their <a href="https://github.com/mozilla-mobile/android-components/blob/master/docs/changelog.md">docs/changelog.md</a>, and update the application-services version there as well in their list of dependency versions.</li>
<li><em><strong>Important: Manually test the changes versus the samples in android-components.</strong></em>
<ul>
<li>We do not have automated test coverage for much of the network functionality at this point, so this is crucial.</li>
<li>You can do this using the smoketest instructions below.
<strong>Note:</strong> iOS smoke tests can only be run on macs.
<ul>
<li>Run the <code>./automation/smoke-test-firefox-ios.py</code> script to test integration with Firefox for iOS.</li>
<li>Run the <code>./automation/smoke-test-android-components.py</code> script to test integration with Android Components.</li>
<li>Run the <code>./automation/smoke-test-fenix.py</code> script to test integration with Fenix.</li>
</ul>
</li>
</ul>
</li>
<li>Get it PRed and landed.</li>
</ol>
</li>
</ol>
<p><strong>Note:</strong> If you need to manually produce the iOS build for some reason (for example, if CircleCI cannot), someone with a mac needs to do the following steps:</p>
<ol>
<li>If necessary, set up for performing iOS builds using <code>./libs/verify-ios-environment.sh</code>.</li>
<li>Run <code>./build-carthage.sh</code> in the root of the repository.</li>
<li>Upload the resulting <code>MozillaAppServices.framework.zip</code> as an attachment on the github release.</li>
</ol>
<hr />
<h2 id="make-a-new-point-release-from-an-existing-release-that-is-behind-latest-main"><a class="header" href="#make-a-new-point-release-from-an-existing-release-that-is-behind-latest-main">Make a new point-release from an existing release that is behind latest main.</a></h2>
<ol>
<li>If necessary, make a new branch named <code>release-vXX</code> which will be used for all point-releases on the <code>vXX.YY.ZZ</code>
series. Example:
<pre><code>git checkout -b release-v72 v72.1.0
git push -u origin release-v72
</code></pre>
</li>
<li>Make a new branch with any fixes to be included in the release, <em>remembering not to make any breaking API changes.</em>. This may involve cherry-picking fixes from main, or developing a new fix directly against the branch. Example:
<pre><code>git checkout -b fixes-for-v72.1.1 release-v72
git cherry-pick 37d35304a4d1d285c8f6f3ce3df3c412fcd2d6c6
git push -u origin fixes-for-v72.1.1
</code></pre>
</li>
<li>Get a PR up with your changes and land them into the &quot;base&quot; branch.
For example, if you are making a <code>release-v72.1.1</code> release, all the changes
you want in that release must already be in the <code>release-v72</code> branch before
following the steps below.</li>
<li>Follow the above steps for cutting a new release from main, except that:
<ul>
<li>When running the <code>./automation/prepare-release.py</code> script, use the <code>--base-branch</code> argument to point it at your release branch, and specify <code>patch</code> as the release type. Example:
<pre><code>./automation/prepare-release.py --base-branch=release-v72 patch
</code></pre>
</li>
<li>When opening a PR to land the commits, target the <code>release-vXX</code> branch rather than main.</li>
<li>When cutting the new release via github's UI, target the <code>release-vXX</code> branch rather than main.</li>
</ul>
</li>
<li>Merge the new release back to main.
<ul>
<li>This will typically require a PR and involve resolving merge conflicts in the changelog.</li>
<li>This ensures we do not accidentally orphan any fixes that were made directly against the release branch,
and also helps ensure that every release has an easily-discoverable changelog entry in main.</li>
<li>When merging the PR, create a merge commit instead of squashing and merging. You can do this by choosing &quot;Merge Pull Request&quot; in GitHub's UI.</li>
<li>GitHub may require you to use admin privileges to merge the PR since the <code>release-vXX</code> branch is most likely not up to date with main. If there are no merge conflicts to resolve and CI checks pass, you can check the checkbox once the PR is approved.</li>
</ul>
</li>
</ol>
<hr />
<h3 id="create-a-release-commit-manually"><a class="header" href="#create-a-release-commit-manually">Create a release commit manually</a></h3>
<ol>
<li>
<p>Update the changelog.</p>
<ol>
<li>
<p>Copy the contents from <code>CHANGES_UNRELEASED.md</code> into the top of <code>CHANGELOG.md</code>, except for the part that links to this document.</p>
</li>
<li>
<p>In <code>CHANGELOG.md</code>:</p>
<ol>
<li>Replace <code># Unreleased Changes</code> with <code># v&lt;new-version-number&gt; (_&lt;current date&gt;_)</code>.</li>
<li>Replace <code>main</code> in the Full Changelog link (which you pasted in from <code>CHANGES_UNRELEASED.md</code>) to be <code>v&lt;new-version-number&gt;</code>. E.g. if you are releasing 0.13.2, the link should be
<pre><code>[Full Changelog](https://github.com/mozilla/application-services/compare/v0.13.1...v0.13.2)
</code></pre>
Note that this needs three dots (<code>...</code>) between the two tags (two dots is different). Yes, the second tag doesn't exist yet, you'll make it later.</li>
<li>Optionally, go over the commits between the past release and this one and see if anything is worth including.</li>
<li>Make sure the changelog follows the format of the other changelog entries. If you have access, <a href="https://docs.google.com/document/d/1oxdGm7OQcsy78NzXjMQKTbfzn21tl9Nopmvo8NCMWmU">this document</a> is fairly comprehensive. For a concrete example, at the time of this writing, see the <a href="https://github.com/mozilla/application-services/blob/main/CHANGELOG.md#0130-2019-01-09">0.13.0</a> release notes.
<ul>
<li>Note that we try to provide PR or issue numbers (and links) for each change. Please add these if they are missing.</li>
</ul>
</li>
</ol>
</li>
<li>
<p>In <code>CHANGES_UNRELEASED.md</code>:</p>
<ol>
<li>Delete the list of changes that are now in the changelog.</li>
<li>Update the &quot;Full Changelog&quot; link so that it starts at your new version and continues to main. E.g. for 60.0.6 this would be
<pre><code>[Full Changelog](https://github.com/mozilla/application-services/compare/v60.0.6...main)
</code></pre>
Again, this needs 3 dots.</li>
</ol>
</li>
</ol>
</li>
<li>
<p>Bump <code>libraryVersion</code> in the top-level <a href="https://github.com/mozilla/application-services/blob/main/.buildconfig-android.yml">.buildconfig-android.yml</a> file. Be sure you're following semver, and if in doubt, ask.</p>
</li>
<li>
<p>Land the commits that perform the steps above. This takes a PR, typically, because of branch protection on main.</p>
</li>
</ol>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/application-services/edit/main/docs/howtos/cut-a-new-release.md">Edit this file on GitHub.</a></footer><div style="break-before: page; page-break-before: always;"></div><h2 id="application-services-build-and-publish-pipeline"><a class="header" href="#application-services-build-and-publish-pipeline">Application Services Build and Publish Pipeline</a></h2>
<p>This document provides an overview of the build-and-publish pipeline used to make our work
in this repo available to consuming applications. It's intended both to document the pipeline
for development and maintenance purposes, and to serve as a basic analysis of the integrity
protections that it offers (so you'll notice there are notes and open questions in place where
we haven't fully hashed out all those details).</p>
<p>The key points:</p>
<ul>
<li>We use &quot;stable&quot; <a href="https://www.rust-lang.org/">Rust</a>. CI is pinned to whatever version is currently used on mozilla-central
to help with vendoring into that repository. You should check what current values are
specified for <a href="../.circleci/config.yml">CircleCI</a> and for <a href="../taskcluster/scripts/toolchain/rustup-setup.sh">TaskCluster</a></li>
<li>We use <a href="https://github.com/rust-lang/cargo">Cargo</a> for building and testing the core Rust code in isolation,
<a href="https://gradle.org/">Gradle</a> with <a href="https://github.com/mozilla/rust-android-gradle">rust-android-gradle</a>
for combining Rust and Kotlin code into Android components and running tests against them,
and <a href="https://github.com/Carthage/Carthage">Carthage</a> driving <a href="../xconfig">XCode</a>
for combining Rust and Swift code into iOS components.</li>
<li><a href="../automation/taskcluster/README.html">TaskCluster</a> runs on every pull-request, release,
and push to main, to ensure Android artifacts build correctly and to execute their
tests via gradle.</li>
<li><a href="../.circleci/config.yml">CircleCI</a> runs on every branch, pull-request (including forks), and release,
to execute lint checks and automated tests at the Rust and Swift level.</li>
<li>Releases are made by <a href="./howtos/cut-a-new-release.html">manually creating a new release</a> via github,
which triggers various CI jobs:
<ul>
<li><a href="../.circleci/config.yml">CircleCI</a> is used to build an iOS binary release on every release,
and publish it as GitHub release artifacts.</li>
<li><a href="../automation/taskcluster/README.html">TaskCluster</a> is used to:
<ul>
<li>Build an Android binary release.</li>
<li>Upload Android library symbols to <a href="https://wiki.mozilla.org/Socorro">Socorro</a>.</li>
<li>Publish it to the <a href="https://maven.mozilla.org">maven.mozilla.org</a>.</li>
</ul>
</li>
</ul>
</li>
<li>Notifications about build failures are sent to a mailing list at
<a href="https://groups.google.com/a/mozilla.com/forum/#!forum/a-s-ci-failures">a-s-ci-failures@mozilla.com</a></li>
<li>Our Taskcluster implementation is almost entirely maintained by the Release Engineering team.
The proper way to contact them in case of emergency or for new developments is to ask on the <code>#releaseduty-mobile</code> Slack channel.
Our main point of contact is @mihai.</li>
</ul>
<p>For Android consumers these are the steps by which Application Services code becomes available,
and the integrity-protection mechanisms that apply at each step:</p>
<ol>
<li>Code is developed in branches and lands on <code>main</code> via pull request.
<ul>
<li>GitHub branch protection prevents code being pushed to <code>main</code> without review.</li>
<li>CircleCI and TaskCluster run automated tests against the code, but do not have
the ability to push modified code back to GitHub thanks to the above branch protection.
<ul>
<li>TaskCluster jobs do not run against PRs opened by the general public,
only for PRs from repo collaborators.</li>
</ul>
</li>
<li>Contra the <a href="https://wiki.mozilla.org/GitHub/Repository_Security">github org security guidelines</a>,
signing of individual commits is encouraged but is <strong>not required</strong>. Our experience in practice
has been that this adds friction for contributors without sufficient tangible benefit.</li>
</ul>
</li>
<li>Developers manually create a release from latest <code>main</code>.
<ul>
<li>The ability to create new releases is managed entirely via github's permission model.</li>
<li>TODO: the <a href="https://wiki.mozilla.org/GitHub/Repository_Security">github org security guidelines</a>
recommend signing tags, and auditing all included commits as part of the release process.
We should consider some tooling to support this. I don't think there's any way to force
githib to only accept signed releases in the same way it can enforce signed commits.</li>
</ul>
</li>
<li>TaskCluster checks out the release tag, builds it for all target platforms, and runs automated tests.
<ul>
<li>These tasks run in a pre-built docker image, helping assure integrity of the build environment.</li>
<li>TODO: could this step check for signed tags as an additional integrity measure?</li>
</ul>
</li>
<li>TaskCluster uploads symbols to Socorro.
<ul>
<li>The access token for this is currently tied to @eoger's LDAP account.</li>
</ul>
</li>
<li>TaskCluster uploads built artifacts to maven.mozilla.org
<ul>
<li>Secret key for uploading to maven is provisioned via TaskCluster,
guarded by a scope that's only available to this task.</li>
<li>TODO: could a malicious dev dependency from step (3) influence the build environment here?</li>
<li>TODO: talk about how TC's &quot;chain of trust&quot; might be useful here.</li>
</ul>
</li>
<li>Consumers fetch the published artifacts from maven.mozilla.org.</li>
</ol>
<p>For iOS consumers the corresponding steps are:</p>
<ol>
<li>Code is developed in branches and lands on <code>main</code> via pull request, as above.</li>
<li>Developers manually create a release from latest <code>main</code>, as above.</li>
<li>CircleCI checks out the release tag, builds it, and runs automated tests.
<ul>
<li>TODO: These tasks bootstrap their build environment by fetching software over https.
could we do more to ensure the integrity of the build environment?</li>
<li>TODO: could this step check for signed tags as an additional integrity measure?</li>
<li>TODO: can we prevent these steps from being able to see the tokens used
for publishing in subsequent steps?</li>
</ul>
</li>
<li>CircleCI builds two binary artifacts:
<ul>
<li>A Carthage framework containing both Rust and Swift code compiled together, as a zipfile.</li>
<li>An XCFramework containing just Rust code and header files, as a zipfile, for use by Swift Packags.</li>
<li>TODO: could a malicious dev dependency from step (3) influence the build environment here?</li>
</ul>
</li>
<li>CircleCI uses <a href="https://github.com/travis-ci/dpl">dpl</a> to publish to GitHub as a release artifact.
<ul>
<li>CircleCI config contains a github token (owned by the @appsvc-moz GitHub account) with appropriate permissions to add release artifacts.</li>
</ul>
</li>
<li>Consumers fetch the published artifacts from GitHub during their build process,
using Carthage.</li>
</ol>
<p>It's worth noting that Carthage will <em>prefer</em> to use the built binary artifacts,
but will happily check out the tag and compile from source itself if such artifacts
are not available.</p>
<p>This is a diagram of the pipeline as it exists (and is planned) for the Nimbus SDK, one of the
libraries in Application Services:
(Source: https://miro.com/app/board/o9J_lWx3jhY=/)</p>
<p><img src="./diagrams/Nimbus-SDK-Build-and-Publish-Pipeline.jpg" alt="Nimbus SDK Build and Publish Pipeline" /></p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/application-services/edit/main/docs/build-and-publish-pipeline.md">Edit this file on GitHub.</a></footer><div style="break-before: page; page-break-before: always;"></div><h1 id="guide-to-upgrading-nss"><a class="header" href="#guide-to-upgrading-nss">Guide to upgrading NSS</a></h1>
<p>Our components rely on cryptographic primitives provided by <a href="https://developer.mozilla.org/docs/Mozilla/Projects/NSS">NSS</a>.
Every month or so, a new version of NSS is <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSS/NSS_Releases">published</a> and we should try to keep our version as up-to-date as possible.</p>
<p>Because it makes unit testing easier on Android, and helps startup performance on iOS, we compile NSS ourselves and link to it statically. Note that NSS is mainly used by Mozilla as a dynamic library and the NSS project is missing related CI jobs (iOS builds, windows cross-compile builds etc.) so you should expect breakage when updating the library (hence this guide).</p>
<h2 id="updating-the-version"><a class="header" href="#updating-the-version">Updating the Version</a></h2>
<p>The build code is located in the <a href="https://github.com/mozilla/application-services/tree/main/libs"><code>libs/</code></a> folder.</p>
<p>The version string is located in the beginning of <a href="https://github.com/mozilla/application-services/blob/b0b3daa6580d04906fc53e9e479e8bebb464cf78/libs/build-all.sh#L8-L11"><code>build-all.sh</code></a>. For most NSS upgrades, the only action needed is to bump the version number in this file and update the downloaded archive checksum.  The actual build invocations are located in platform-specific script files (e.g. <a href="https://github.com/mozilla/application-services/blob/b0b3daa6580d04906fc53e9e479e8bebb464cf78/libs/build-nss-ios.sh"><code>build-nss-ios.sh</code></a>) but usually don't require any changes.</p>
<p>Due to the complexity of the NSS build process, we currently use pre-built artifacts
for running tests on MacOS and Win32 desktop machines (ref <a href="https://github.com/mozilla/application-services/issues/962">#962</a>). You can regenerate these artifacts by taking advantage of the <a href="https://wiki.mozilla.org/NSS:TryServer">NSS TryServer</a> infrastructure, with some patches to the NSS source:</p>
<ol>
<li>Get the source for NSS:
<ul>
<li><code>hg clone https://hg.mozilla.org/projects/nss</code></li>
<li><code>cd nss</code></li>
</ul>
</li>
<li>Apply <a href="https://phabricator.services.mozilla.com/D30511">this patch</a> for Windows mingw build support, rebasing it on top
of the release tag for the target NSS version:
<ul>
<li><code>moz-phab patch --apply-to NSS_&lt;X&gt;_&lt;YY&gt;_RTM D30511</code></li>
</ul>
</li>
<li>Do your best to fix up any conflicts that may have resulted from the rebase, sorry :-(
<ul>
<li>The rejected hunks of the patch can be found with <code>find . -name &quot;*.rej&quot;</code>.</li>
<li>You will need to <code>hg commit -A</code> any manual changes before proceeding to the next step.</li>
</ul>
</li>
<li>Apply the patch from <a href="howtos/../../libs/build-nss-static-libs.patch">/libs/build-nss-static-libs.patch</a> to make the tryserver build static artifacts.
<ul>
<li><code>hg patch ../application-services/libs/build-nss-static-libs.patch</code></li>
</ul>
</li>
<li>Do your best to fix up any conflicts that may have resulted from an outdated patch, sorry :-(
<ul>
<li>As above, you will need to <code>hg commit -A</code> any manual changes before proceeding to the next step.</li>
</ul>
</li>
<li>Follow <a href="https://wiki.mozilla.org/NSS:TryServer#Pushing_to_nss-try">these instructions</a> to push the resulting
commit to try.
<ul>
<li>Confirm that all your changes have been committed.</li>
<li>Make sure you've added the <code>nss-try</code> path to your <code>.hg/hgrc</code> config.</li>
<li>Update the commit message to limit the number of jobs that are run.
<ul>
<li><code>hg commit --amend --message &quot;try: -b opt -p mac,linux64-mingw-w64 -u none -t none&quot;</code></li>
</ul>
</li>
<li><code>hg push -r . -f nss-try</code></li>
<li>Visit the <a href="https://treeherder.mozilla.org/jobs?repo=nss-try">tryserver dashboard</a> and find the resulting job.
<ul>
<li>If you can't find it, try adding <code>&amp;author=you@mozilla.com</code> to the query string for filtering.</li>
</ul>
</li>
</ul>
</li>
<li>Once the build has completed, find the generated artifacts and download them.
<ul>
<li>
<p>The necessary UI looks like this:
<img src="howtos/./img/nss_tryserver_artifacts.png" /></p>
</li>
<li>
<p>For MacOS builds, download from the job named &quot;mac opt&quot;.</p>
</li>
<li>
<p>For Windows builds, download from the job named &quot;linux64-mingw-w64 opt&quot;.</p>
</li>
<li>
<p>Rename the files to <code>nss_nspr_static_&lt;X&gt;.&lt;YY&gt;_&lt;darwin|mingw&gt;.&lt;ext&gt;</code> following the pattern used by existing files.</p>
</li>
</ul>
</li>
<li>Upload the resulting files to S3 at <a href="https://fxa-dev-bucket.s3-us-west-2.amazonaws.com/a-s/">https://fxa-dev-bucket.s3-us-west-2.amazonaws.com/a-s/</a>.
<ul>
<li>You'll need an account in the <a href="https://cloudservices-aws-dev.signin.aws.amazon.com/">Cloud Services AWS Dev Console</a>.
Find out more on the <a href="https://mana.mozilla.org/wiki/display/SVCOPS/AWS">SVCOPS AWS Mana page</a>.</li>
</ul>
</li>
</ol>
<p>Once these files have been uploaded, update the URLs and corresponding checksums in
<a href="https://github.com/mozilla/application-services/blob/bb5ff1b649bddae9bbd9157f4023304c467e388e/libs/build-nss-desktop.sh#L59-L74">build-nss-desktop.sh</a>.</p>
<p>This process is far from optimal; <a href="https://github.com/mozilla/application-services/issues/962">#962</a> tracks the work of further automating these steps.</p>
<p>To test out your changes:</p>
<ul>
<li>Clear any old NSS build artifacts: <code>rm -rf ./libs/desktop &amp;&amp; cargo clean</code></li>
<li>Install the updates version: <code>./libs/verify-desktop-environment.sh</code></li>
<li>Try it out: <code>cargo test</code></li>
</ul>
<h2 id="exposing-new-functions"><a class="header" href="#exposing-new-functions">Exposing new functions</a></h2>
<p>If the new version of NSS comes with new functions that you want to expose, you will need to:</p>
<ul>
<li>Add low-level bindings for those functions in the <a href="howtos/../../components/support/rc_crypto/nss/nss_sys"><code>nss_sys</code> crate</a>; follow the instructions in
README for that crate.</li>
<li>Expose a safe wrapper API for the functions from the <a href="howtos/../../components/support/rc_crypto/nss"><code>nss</code> crate</a>;</li>
<li>Expose a convenient high-level API for the functions from the <a href="howtos/../../components/support/rc_crypto"><code>rc_crypto</code> crate</a>;</li>
</ul>
<h2 id="tips-for-fixing-bustage"><a class="header" href="#tips-for-fixing-bustage">Tips for Fixing Bustage</a></h2>
<p>On top of the primitives provided by NSS, we have built a safe Rust wrapper named <a href="https://github.com/mozilla/application-services/tree/main/components/support/rc_crypto">rc_crypto</a> that links to NSS and makes these cryptographic primitives available to our components.</p>
<p>The linkage is done by the <a href="https://github.com/mozilla/application-services/blob/b0b3daa6580d04906fc53e9e479e8bebb464cf78/components/support/rc_crypto/nss/nss_build_common/src/lib.rs"><code>nss_build_common</code></a> crate. Note that it supports a <code>is_gecko</code> feature to link to NSS dynamically on Desktop.</p>
<p>Because the NSS static build process does not output a single <code>.a</code> file (it would be great if it did), this file must <a href="https://github.com/mozilla/application-services/blob/b0b3daa6580d04906fc53e9e479e8bebb464cf78/components/support/rc_crypto/nss/nss_build_common/src/lib.rs#L85-L133">describe</a> for each architecture which modules should we link against. It is mostly a duplication of logic from the <a href="https://searchfox.org/nss/rev/d0ca572a63597a19889611c065273f131cc09b7a/lib/freebl/freebl.gyp#385-408">NSS gyp build files</a>. Note that this logic is also duplicated in our NSS lib build steps (e.g. <a href="https://github.com/mozilla/application-services/blob/b0b3daa6580d04906fc53e9e479e8bebb464cf78/libs/build-nss-desktop.sh#L82-L114">build-nss-desktop.sh</a>).</p>
<p>One of the most common build failures we get when upgrading NSS comes from NSS adding new vectorized/asm versions of a crypto algorithm for a specific architecture in order to improve performance. This new optimized code gets implemented as a new gyp target/module that is emitted only for the supported architectures.
When we upgrade our copy of NSS we notice the linking step failing on CI jobs because of undefined symbols.</p>
<p><a href="https://github.com/mozilla/application-services/pull/2476">This PR</a> shows how we update <code>nss_common_build</code> and the build scripts to accommodate for these new modules. Checking the changelog for any suspect commit relating to hardware acceleration is rumored to help.</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/application-services/edit/main/docs/howtos/upgrading-nss-guide.md">Edit this file on GitHub.</a></footer><div style="break-before: page; page-break-before: always;"></div><!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Firefox Accounts Client"><meta name="keywords" content="rust, rustlang, rust-lang, fxa_client"><title>fxa_client - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../ayu.css" disabled ><script id="default-settings" ></script><script src="../storage.js"></script><script src="../crates.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="icon" type="image/svg+xml" href="../favicon.svg"><link rel="alternate icon" type="image/png" href="../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../fxa_client/index.html'><div class='logo-container rust-logo'><img src='../rust-logo.png' alt='logo'></div></a><h2 class="location">Crate fxa_client</h2><div class="block version"><div class="narrow-helper"></div><p>Version 0.1.0</p></div><div class="sidebar-elems"><a id="all-types" href="rust-docs/fxa_client/all.html"><p>See all fxa_client's items</p></a><div class="block items"><ul><li><a href="rust-docs/fxa_client/index.html#modules">Modules</a></li><li><a href="rust-docs/fxa_client/index.html#structs">Structs</a></li><li><a href="rust-docs/fxa_client/index.html#enums">Enums</a></li></ul></div><div id="sidebar-vars" data-name="fxa_client" data-ty="mod" data-relpath=""></div><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="18" height="18" alt="Pick another theme!" src="rust-docs/fxa_client/../brush.svg"></button><div id="theme-choices" role="menu"></div></div><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input"name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="rust-docs/fxa_client/../settings.html" title="settings"><img width="18" height="18" alt="Change settings" src="rust-docs/fxa_client/../wheel.svg"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Crate <a class="mod" href="rust-docs/fxa_client/index.html#">fxa_client</a><button id="copy-path" onclick="copy_path(this)" title="copy path"><img src="rust-docs/fxa_client/../clipboard.svg" width="19" height="18" alt="Copy item import" title="Copy item import to clipboard"></button></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="rust-docs/fxa_client/../src/fxa_client/lib.rs.html#5-1337" title="goto source code">[src]</a></span></h1><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h1 id="firefox-accounts-client" class="section-header"><a href="rust-docs/fxa_client/index.html#firefox-accounts-client">Firefox Accounts Client</a></h1>
<p>The fxa-client component lets applications integrate with the
<a href="https://mozilla.github.io/ecosystem-platform/docs/features/firefox-accounts/fxa-overview">Firefox Accounts</a>
identity service. The shape of a typical integration would look
something like:</p>
<ul>
<li>
<p>Out-of-band, register your application with the Firefox Accounts service,
providing an OAuth <code>redirect_uri</code> controlled by your application and
obtaining an OAuth <code>client_id</code>.</p>
</li>
<li>
<p>On application startup, create a <a href="rust-docs/fxa_client/struct.FirefoxAccount.html" title="FirefoxAccount"><code>FirefoxAccount</code></a> object to represent the
signed-in state of the application.</p>
<ul>
<li>On first startup, a new <a href="rust-docs/fxa_client/struct.FirefoxAccount.html" title="FirefoxAccount"><code>FirefoxAccount</code></a> can be created by calling
<a href="rust-docs/fxa_client/struct.FirefoxAccount.html#method.new" title="FirefoxAccount::new"><code>FirefoxAccount::new</code></a> and passing the application’s <code>client_id</code>.</li>
<li>For subsequent startups the object can be persisted using the
<a href="rust-docs/fxa_client/struct.FirefoxAccount.html#method.to_json"><code>to_json</code></a> method and re-created by
calling <a href="rust-docs/fxa_client/struct.FirefoxAccount.html#method.from_json" title="FirefoxAccount::from_json"><code>FirefoxAccount::from_json</code></a>.</li>
</ul>
</li>
<li>
<p>When the user wants to sign in to your application, direct them through
a web-based OAuth flow using <a href="rust-docs/fxa_client/struct.FirefoxAccount.html#method.begin_oauth_flow"><code>begin_oauth_flow</code></a>
or <a href="rust-docs/fxa_client/struct.FirefoxAccount.html#method.begin_pairing_flow"><code>begin_pairing_flow</code></a>; when they return
to your registered <code>redirect_uri</code>, pass the resulting authorization state back to
<a href="rust-docs/fxa_client/struct.FirefoxAccount.html#method.complete_oauth_flow"><code>complete_oauth_flow</code></a> to sign them in.</p>
</li>
<li>
<p>Display information about the signed-in user by using the data from
<a href="rust-docs/fxa_client/struct.FirefoxAccount.html#method.get_profile"><code>get_profile</code></a>.</p>
</li>
<li>
<p>Access account-related services on behalf of the user by obtaining OAuth
access tokens via <a href="rust-docs/fxa_client/struct.FirefoxAccount.html#method.get_access_token"><code>get_access_token</code></a>.</p>
</li>
<li>
<p>If the user opts to sign out of the application, calling <a href="rust-docs/fxa_client/struct.FirefoxAccount.html#method.disconnect"><code>disconnect</code></a>
and then discarding any persisted account data.</p>
</li>
</ul>
</div></details><h2 id="modules" class="section-header"><a href="rust-docs/fxa_client/index.html#modules">Modules</a></h2>
<div class="item-table"><div class="item-left module-item"><a class="mod" href="rust-docs/fxa_client/internal/index.html" title="fxa_client::internal mod">internal</a></div><div class="item-right docblock-short"><p>Internal implementation details for the fxa_client crate.</p>
</div></div><h2 id="structs" class="section-header"><a href="rust-docs/fxa_client/index.html#structs">Structs</a></h2>
<div class="item-table"><div class="item-left module-item"><a class="struct" href="rust-docs/fxa_client/struct.AccessTokenInfo.html" title="fxa_client::AccessTokenInfo struct">AccessTokenInfo</a></div><div class="item-right docblock-short"><p>An OAuth access token, with its associated keys and metadata.</p>
</div><div class="item-left module-item"><a class="struct" href="rust-docs/fxa_client/struct.AttachedClient.html" title="fxa_client::AttachedClient struct">AttachedClient</a></div><div class="item-right docblock-short"><p>A client connected to the user’s account.</p>
</div><div class="item-left module-item"><a class="struct" href="rust-docs/fxa_client/struct.AuthorizationInfo.html" title="fxa_client::AuthorizationInfo struct">AuthorizationInfo</a></div><div class="item-right docblock-short"><p>Information about the authorization state of the application.</p>
</div><div class="item-left module-item"><a class="struct" href="rust-docs/fxa_client/struct.AuthorizationParameters.html" title="fxa_client::AuthorizationParameters struct">AuthorizationParameters</a></div><div class="item-right docblock-short"><p>Parameters provided in an incoming OAuth request.</p>
</div><div class="item-left module-item"><a class="struct" href="rust-docs/fxa_client/struct.Device.html" title="fxa_client::Device struct">Device</a></div><div class="item-right docblock-short"><p>A device connected to the user’s account.</p>
</div><div class="item-left module-item"><a class="struct" href="rust-docs/fxa_client/struct.DevicePushSubscription.html" title="fxa_client::DevicePushSubscription struct">DevicePushSubscription</a></div><div class="item-right docblock-short"><p>Details of a web-push subscription endpoint.</p>
</div><div class="item-left module-item"><a class="struct" href="rust-docs/fxa_client/struct.FfiConverterTypeAccessTokenInfo.html" title="fxa_client::FfiConverterTypeAccessTokenInfo struct">FfiConverterTypeAccessTokenInfo</a></div><div class="item-right docblock-short"></div><div class="item-left module-item"><a class="struct" href="rust-docs/fxa_client/struct.FfiConverterTypeAccountEvent.html" title="fxa_client::FfiConverterTypeAccountEvent struct">FfiConverterTypeAccountEvent</a></div><div class="item-right docblock-short"></div><div class="item-left module-item"><a class="struct" href="rust-docs/fxa_client/struct.FfiConverterTypeAttachedClient.html" title="fxa_client::FfiConverterTypeAttachedClient struct">FfiConverterTypeAttachedClient</a></div><div class="item-right docblock-short"></div><div class="item-left module-item"><a class="struct" href="rust-docs/fxa_client/struct.FfiConverterTypeAuthorizationInfo.html" title="fxa_client::FfiConverterTypeAuthorizationInfo struct">FfiConverterTypeAuthorizationInfo</a></div><div class="item-right docblock-short"></div><div class="item-left module-item"><a class="struct" href="rust-docs/fxa_client/struct.FfiConverterTypeAuthorizationParameters.html" title="fxa_client::FfiConverterTypeAuthorizationParameters struct">FfiConverterTypeAuthorizationParameters</a></div><div class="item-right docblock-short"></div><div class="item-left module-item"><a class="struct" href="rust-docs/fxa_client/struct.FfiConverterTypeDevice.html" title="fxa_client::FfiConverterTypeDevice struct">FfiConverterTypeDevice</a></div><div class="item-right docblock-short"></div><div class="item-left module-item"><a class="struct" href="rust-docs/fxa_client/struct.FfiConverterTypeDeviceCapability.html" title="fxa_client::FfiConverterTypeDeviceCapability struct">FfiConverterTypeDeviceCapability</a></div><div class="item-right docblock-short"></div><div class="item-left module-item"><a class="struct" href="rust-docs/fxa_client/struct.FfiConverterTypeDevicePushSubscription.html" title="fxa_client::FfiConverterTypeDevicePushSubscription struct">FfiConverterTypeDevicePushSubscription</a></div><div class="item-right docblock-short"></div><div class="item-left module-item"><a class="struct" href="rust-docs/fxa_client/struct.FfiConverterTypeDeviceType.html" title="fxa_client::FfiConverterTypeDeviceType struct">FfiConverterTypeDeviceType</a></div><div class="item-right docblock-short"></div><div class="item-left module-item"><a class="struct" href="rust-docs/fxa_client/struct.FfiConverterTypeFxAMigrationResult.html" title="fxa_client::FfiConverterTypeFxAMigrationResult struct">FfiConverterTypeFxAMigrationResult</a></div><div class="item-right docblock-short"></div><div class="item-left module-item"><a class="struct" href="rust-docs/fxa_client/struct.FfiConverterTypeFxaError.html" title="fxa_client::FfiConverterTypeFxaError struct">FfiConverterTypeFxaError</a></div><div class="item-right docblock-short"></div><div class="item-left module-item"><a class="struct" href="rust-docs/fxa_client/struct.FfiConverterTypeIncomingDeviceCommand.html" title="fxa_client::FfiConverterTypeIncomingDeviceCommand struct">FfiConverterTypeIncomingDeviceCommand</a></div><div class="item-right docblock-short"></div><div class="item-left module-item"><a class="struct" href="rust-docs/fxa_client/struct.FfiConverterTypeMetricsParams.html" title="fxa_client::FfiConverterTypeMetricsParams struct">FfiConverterTypeMetricsParams</a></div><div class="item-right docblock-short"></div><div class="item-left module-item"><a class="struct" href="rust-docs/fxa_client/struct.FfiConverterTypeMigrationState.html" title="fxa_client::FfiConverterTypeMigrationState struct">FfiConverterTypeMigrationState</a></div><div class="item-right docblock-short"></div><div class="item-left module-item"><a class="struct" href="rust-docs/fxa_client/struct.FfiConverterTypeProfile.html" title="fxa_client::FfiConverterTypeProfile struct">FfiConverterTypeProfile</a></div><div class="item-right docblock-short"></div><div class="item-left module-item"><a class="struct" href="rust-docs/fxa_client/struct.FfiConverterTypeScopedKey.html" title="fxa_client::FfiConverterTypeScopedKey struct">FfiConverterTypeScopedKey</a></div><div class="item-right docblock-short"></div><div class="item-left module-item"><a class="struct" href="rust-docs/fxa_client/struct.FfiConverterTypeSendTabPayload.html" title="fxa_client::FfiConverterTypeSendTabPayload struct">FfiConverterTypeSendTabPayload</a></div><div class="item-right docblock-short"></div><div class="item-left module-item"><a class="struct" href="rust-docs/fxa_client/struct.FfiConverterTypeTabHistoryEntry.html" title="fxa_client::FfiConverterTypeTabHistoryEntry struct">FfiConverterTypeTabHistoryEntry</a></div><div class="item-right docblock-short"></div><div class="item-left module-item"><a class="struct" href="rust-docs/fxa_client/struct.FirefoxAccount.html" title="fxa_client::FirefoxAccount struct">FirefoxAccount</a></div><div class="item-right docblock-short"><p>Object representing the signed-in state of an application.</p>
</div><div class="item-left module-item"><a class="struct" href="rust-docs/fxa_client/struct.FxAMigrationResult.html" title="fxa_client::FxAMigrationResult struct">FxAMigrationResult</a></div><div class="item-right docblock-short"><p>Statistics about the completion of a migration from legacy sign-in data.</p>
</div><div class="item-left module-item"><a class="struct" href="rust-docs/fxa_client/struct.MetricsParams.html" title="fxa_client::MetricsParams struct">MetricsParams</a></div><div class="item-right docblock-short"><p>Additional metrics tracking parameters to include in an OAuth request.</p>
</div><div class="item-left module-item"><a class="struct" href="rust-docs/fxa_client/struct.Profile.html" title="fxa_client::Profile struct">Profile</a></div><div class="item-right docblock-short"><p>Information about the user that controls a Firefox Account.</p>
</div><div class="item-left module-item"><a class="struct" href="rust-docs/fxa_client/struct.ScopedKey.html" title="fxa_client::ScopedKey struct">ScopedKey</a></div><div class="item-right docblock-short"><p>A cryptograpic key associated with an OAuth scope.</p>
</div><div class="item-left module-item"><a class="struct" href="rust-docs/fxa_client/struct.SendTabPayload.html" title="fxa_client::SendTabPayload struct">SendTabPayload</a></div><div class="item-right docblock-short"><p>The payload sent when invoking a “send tab” command.</p>
</div><div class="item-left module-item"><a class="struct" href="rust-docs/fxa_client/struct.TabHistoryEntry.html" title="fxa_client::TabHistoryEntry struct">TabHistoryEntry</a></div><div class="item-right docblock-short"><p>An individual entry in the navigation history of a sent tab.</p>
</div></div><h2 id="enums" class="section-header"><a href="rust-docs/fxa_client/index.html#enums">Enums</a></h2>
<div class="item-table"><div class="item-left module-item"><a class="enum" href="rust-docs/fxa_client/enum.AccountEvent.html" title="fxa_client::AccountEvent enum">AccountEvent</a></div><div class="item-right docblock-short"><p>An event that happened on the user’s account.</p>
</div><div class="item-left module-item"><a class="enum" href="rust-docs/fxa_client/enum.DeviceCapability.html" title="fxa_client::DeviceCapability enum">DeviceCapability</a></div><div class="item-right docblock-short"><p>A “capability” offered by a device.</p>
</div><div class="item-left module-item"><a class="enum" href="rust-docs/fxa_client/enum.DeviceType.html" title="fxa_client::DeviceType enum">DeviceType</a></div><div class="item-right docblock-short"><p>Enumeration for the different types of device.</p>
</div><div class="item-left module-item"><a class="enum" href="rust-docs/fxa_client/enum.FxaError.html" title="fxa_client::FxaError enum">FxaError</a></div><div class="item-right docblock-short"><p>Generic error type thrown by many <a href="rust-docs/fxa_client/struct.FirefoxAccount.html" title="FirefoxAccount"><code>FirefoxAccount</code></a> operations.</p>
</div><div class="item-left module-item"><a class="enum" href="rust-docs/fxa_client/enum.IncomingDeviceCommand.html" title="fxa_client::IncomingDeviceCommand enum">IncomingDeviceCommand</a></div><div class="item-right docblock-short"><p>A command invoked by another device.</p>
</div><div class="item-left module-item"><a class="enum" href="rust-docs/fxa_client/enum.MigrationState.html" title="fxa_client::MigrationState enum">MigrationState</a></div><div class="item-right docblock-short"><p>The current state migration from legacy sign-in data.</p>
</div></div></section><section id="search" class="content hidden"></section><div id="rustdoc-vars" data-root-path="../" data-current-crate="fxa_client" data-search-index-js="../search-index.js" data-search-js="../search.js"></div>
    <script src="../main.js"></script>
</body></html>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/application-services/edit/main/docs/rust-docs/fxa_client/index.html">Edit this file on GitHub.</a></footer><div style="break-before: page; page-break-before: always;"></div><h1 id="developing-documentation"><a class="header" href="#developing-documentation">Developing documentation</a></h1>
<p>The documentation in this repository pertains to the application-services library, primarily the sync and storage components, firefox account client and the nimbus-sdk experimentation client.</p>
<p>The markdown is converted to static HTML using <a href="https://rust-lang.github.io/mdBook/">mdbook</a>.  To add a new document, you need to add it to the SUMMARY.md file which produces the sidebar table of contents.</p>
<h2 id="building-documentation"><a class="header" href="#building-documentation">Building documentation</a></h2>
<h3 id="building-the-narrative-book-documentation"><a class="header" href="#building-the-narrative-book-documentation">Building the narrative (book) documentation</a></h3>
<p>The <code>mdbook</code> crate is required in order to build the documentation:</p>
<pre><code class="language-sh">cargo install mdbook mdbook-mermaid mdbook-open-on-gh
</code></pre>
<p>The repository documents are be built with:</p>
<pre><code class="language-sh">./tools/build.docs.sh
</code></pre>
<p>The built documentation is saved in <code>build/docs/book</code>.</p>
<footer id="open-on-gh">Found a bug? <a href="https://github.com/mozilla/application-services/edit/main/docs/adding-docs.md">Edit this file on GitHub.</a></footer>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="shared/tabs.js"></script>
        <script type="text/javascript" src="shared/mermaid.min.js"></script>
        <script type="text/javascript" src="shared/mermaid-init.js"></script>

        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </body>
</html>
